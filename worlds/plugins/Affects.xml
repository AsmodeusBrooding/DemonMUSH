<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, June 17, 2019, 8:08 PM -->
<!-- MuClient version 5.06-pre -->

<!-- Plugin "bloot_odds" generated by Plugin Wizard -->

<muclient>
<plugin
   name="bloot_odds"
   author="Castiel"
   id="ca81c6d49fc8651517f995ab"
   language="Lua"
   purpose="Tracks bonus loot odds"
   save_state="y"
   date_written="2019-06-17 20:07:58"
   requires="5.06"
   version="1.0"
   >
   <description trim="n">
   		<![CDATA[
.----------------------------------------------------------------------------.
|                           Bonus Loot Tracker Helper                        |
|----------------------------------------------------------------------------|
| bloot help -- Brings up the help section. (What you are reading now)       |
|                                                                            |
| bloot window       -- Toggles showing/hiding of mini window.               |
| bloot clear|reset  -- Clear any gathered data.                             |
| bloot window reset -- Reset window position/etc.                           |
|                                                                            |
| bloot report <channel> -- Report statistics to channel supplied.           |
'----------------------------------------------------------------------------'
]]>
</description>
</plugin>


<aliases>
  <alias regexp="y" match="^bloot( help)?$" enabled="y" script="Help"></alias>
  <alias regexp="y" match="^bloot (clear|reset)$" enabled="y" script="manualReset"></alias>
  <alias regexp="y" match="^bloot rep(ort)? (?<channel>.*)$" enabled="y" script="reportData"></alias>
  <alias regexp="y" match="drawaff" enabled="y" send_to="14"><send>draw_affects()</send></alias>

  <alias regexp="y" match="^bloot window$" enabled="y" script="toggleWindow" ignore_case="y" sequence="100"></alias>
  <alias regexp="y" match="^bloot window reset$" enabled="y" script="ResetWindow" ignore_case="y" sequence="100"></alias>
</aliases>

<triggers>
 <trigger group="blootItemKill" regexp="y" match="^You receive (.*?) experience points\.$" enabled="y" sequence="100" script="KillLoot"></trigger>
   <trigger group="blootItem" regexp="y" match="^You get (\((?<enhanced>.*?)\) )?(?<item>.*?) from the (.*?)?corpse of (.*?)\.$" enabled="y" sequence="100" script="updateLoot"></trigger>
   <trigger group="blootItemCrumble" regexp="y" match="^(?<item>.*?) crumbles into (.*?) gold pieces\.$" enabled="y" sequence="100" script="cancelLoot"></trigger>
   
</triggers>

<include name="constants.lua"/>

<script>
<![CDATA[
   require "serialize"
   require "commas"

   -- Window related variables
   local z_order_plugin = "462b665ecb569efbf261422f"
	local dragStart = nil	
	local window = {}	
local msdp = {}
   -- Variables
   local tag = "@x238[@YB@yo@Wn@Yu@ys @WL@Yo@yo@Wt@x238]@w"
   local bloot = {}
   local blootLookup = { ["Normal"] = "silver", --No tag!
                         ["Kills"] = "red", --No tag!
                         ["Polished"] = "lime", --Green
                         ["Enhanced"] = "lime",
                         ["Burnished"] = "lime",
                         ["Shiny"] = "lime",
                         ["Vibrant"] = "lime",
                         ["Sparkling"] = "lime",
                         ["Gleaming"] = "lime",
                         ["Shimmering"] = "lime",
                         ["Dazzling"] = "lime",
                         ["Brilliant"] = "lime",
                         ["Radiant"] = "red", --Red
                         ["Wondrous"] = "red",
                         ["Majestic"] = "red",
                         ["Exalted"] = "red",
                         ["Eternal"] = "red",
                         ["Legendary"] = "yellow", --Yellow
                         ["Epic"] = "yellow",
                         ["Mythical"] = "yellow",
                         ["Divine"] = "yellow",
                         ["Fabled"] = "yellow",
                         ["Godly"] = "blue" --Top end?
                        }

   function Help()
		ColourNote("orange", "black", GetPluginInfo (GetPluginID (), 3))
   end
   
   function OnPluginInstall()
		if (GetVariable("window") ~= nil) then	
			-- load saved variables if they exist
			luastmt = "obj = " .. GetVariable("window")
			assert (loadstring (luastmt or "")) ()		
			window = obj
		else
			SetWindowDefaults() -- load window defaults
		end					
		
		if (GetVariable("blootData") ~= nil) then
			-- load saved variables if they exist
			luastmt = "obj = " .. GetVariable("blootData")
			assert (loadstring (luastmt or "")) ()
         bloot = obj
      else
         resetData()
		end

		InitializeWindow()				
      Help()
   end

   function OnPluginClose()
		DeleteWindow()
   end

   function reportData(name, line, wildcards)
      local tStr = wildcards.channel .. " " .. tag .. " "
      local total = 0

      for k, v in pairs(bloot) do
         total = bloot["Kills"]
      end

      for k, v in spairs(bloot, function(t,a,b) return t[a] > t[b] end) do
         tStr = tStr .. "@x250" .. k .. "@x238: @W" .. v .. "@R (@W" .. string.format("%.3f%%", (v/total)*100) .. "@R) "
      end

      Send(tStr)
   end

   function resetData()
      bloot = { }
      SetVariable("blootData", serialize.save_simple(bloot))
   end

   function manualReset()
      resetData()
      ColourNote("orange", "", "Bonus loot data reset!")
      Draw(window)
   end

   function KillLoot()
if bloot["Kills"] == nil then  bloot["Kills"] = 0
end
bloot["Kills"] = tonumber(bloot["Kills"]) + 1
      SetVariable("blootData", serialize.save_simple(bloot)) --Save updated info
      Draw(window)
end

   function updateLoot(name, line, wildcards)
      local amount = 1

      if string.find(wildcards.item, "gold coins") ~= nil then
         return --Looted gold coins, ignore
      end

      local tAmt = string.match(wildcards.item, "^%d+ %*")

      if tAmt ~= nil then
         tAmt = string.match(tAmt, "^%d+")
         amount = tonumber(tAmt) --Looted multiple of a single item, aka "You get 5 * an item from a corpse."
      end

      local iType = ""
      if wildcards.enhanced == nil or wildcards.enhanced == "" then
         iType = "Normal"
      else
         if blootLookup[wildcards.enhanced] == nil then
            return --Unknown bonus type, ignore
         end
         iType = wildcards.enhanced
      end
      iType = string.gsub(iType, "%(", "") --In case of Godly, it has 2 (
      iType = string.gsub(iType, "%)", "") --In case of Godly, it has 2 )

      if bloot[iType] == nil then
         bloot[iType] = 0
      end
if iType == "Normal" then return end
      bloot[iType] = tonumber(bloot[iType]) + amount
      SetVariable("blootData", serialize.save_simple(bloot)) --Save updated info
      Draw(window)
   end

   function cancelLoot()
      if bloot["Normal"] == nil then
         bloot["Normal"] = 0
      end
      bloot["Normal"] = tonumber(bloot["Normal"]) - 1 --Since this is only called on crumbles, it can only ever be "Normal"
   end

   function spairs(t, order)
      -- collect the keys
      local keys = {}
      for k in pairs(t) do keys[#keys+1] = k end

      -- if order function given, sort by it by passing the table and keys a, b,
      -- otherwise just sort the keys 
      if order then
         table.sort(keys, function(a,b) return order(t, a, b) end)
      else
         table.sort(keys)
      end

      -- return the iterator function
      local i = 0
      return function()
         i = i + 1
         if keys[i] then
            return keys[i], t[keys[i]]
         end
      end
   end

local AffectIcon = {}
local AffectName = {}
local AffectType = {}
local AffectDuration = {}
local AffectMax = 0

function init_affects (data)

  index = 0
  startpos = 1
  max = 0
  for i=1,string.len(data),1 do
    if string.byte(data,i) == 7 or i == string.len(data) then
      if string.byte(data,i) == 7 then
        endpos = 1
      else
        endpos = 0
      end -- if
      variable = string.sub(data,startpos,i-endpos)
      startpos = i+1
      index = index + 1

      pos1 = string.find(variable, ",")
      if pos1 ~= nil then
        pos2 = string.find(variable, ",", pos1+1)
        if pos2 ~= nil then
          pos3 = string.find(variable, ",", pos2+1)
        end -- if
        if pos3 ~= nil then
          AffectIcon[index] = string.sub(variable, 1, pos1-1)..".png"
          AffectType[index] = string.sub(variable, pos1+1, pos2-1)
          AffectName[index] = string.sub(variable, pos2+1, pos3-1)
          AffectDuration[index] = string.sub(variable, pos3+1)

          -- Don't display duplicates
          if index > 1 and AffectName[index] == AffectName[index-1] then
            index = index - 1
          end -- if
        end -- if
      else -- we've only got the duration
        AffectDuration[index] = variable
      end -- if
    end -- if
  end -- for

  -- AffectMax is the highest EVER number - we need to keep track of all created icons
  if index < AffectMax then
    for i=index+1,AffectMax,1 do
      AffectIcon[i] = nil
      win = "affect_window_"..i
      WindowShow (win, false)
    end -- for
    AffectMax = index
  elseif index > AffectMax then
    AffectMax = index
  end -- if

end -- function

function draw_affects ()

  affects = msdp["AFFECTS"]
  if affects == nil or affects == "None" then
    for i=1,AffectMax,1 do
      WindowShow ("affect_window_"..i, false)
    end -- for
    AffectMax = 0
    return
  end -- if

  init_affects (affects)

  offset_x = 0
  offset_y = 0

  for i=1,AffectMax,1 do
    if AffectName[i] ~= nil then
      win = "affect_window_"..i
      affect = "affect_"..i

      -- draw the icons left to right, top to bottom
      if i > 1 then
        if offset_x == 0 then
          offset_x = 36
        else
          offset_x = 0
          offset_y = offset_y + 36
        end -- if
      end -- if

      colour = border_colour

      -- make a miniwindow under the text
      check (WindowCreate (win,   -- window ID
                    5+offset_x,   -- left
                    121+offset_y, -- top
                    34,           -- width
                    34,           -- depth
                    12,           -- center it (ignored anyway) 
                    2,            -- draw underneath (1) + absolute location (2)
                    colour))      -- background colour


      -- load the icon background image if possible
      if WindowLoadImage (win, affect, GetInfo (66) .. "images_4D/layout/affect_background.png") == eOK then
        check (WindowDrawImage (win, affect, 0, 0, 0, 0, 1))  -- draw it
      end -- if

      -- load the icon
      if WindowLoadImage (win, affect, GetInfo (66) .. "images_4D/affects/" .. AffectName[i] .. ".png") == eOK then
        check (WindowDrawImage (win, affect, 3, 3, 31, 31, 2))  -- draw the icon
      elseif WindowLoadImage (win, affect, GetInfo (66) .. "images_4D/affects/001.png") == eOK then
        check (WindowDrawImage (win, affect, 3, 3, 31, 31, 2))  -- draw the default icon instead
      else -- even the default spell icon is missing
        Note( "Missing spell icons.")
        return
      end -- if

      -- create the pie-shape - based on an example by Nick Gammon
      timer = tonumber(AffectDuration[i])
      if timer > 0 and timer < 60 then
        percent = timer / 60.0
        tempwin = GetPluginID() .. ":temp"
        backgroundColour = ColourNameToRGB ("white")

        -- for drawing cooldowns (window not visible)
        WindowCreate (tempwin, 
                   3, 3,   -- left, top 
                   28,     -- width
                   28,     -- height
                   12,     -- position mode
                   0,      -- flags
                   backgroundColour) 

        -- calculate pie end point
        endx = (math.cos(math.rad (percent * 360 + 90)) * 28) + 14
        endy = (-1 * math.sin(math.rad (percent * 360 + 90)) * 28) + 14

        -- clear temporary window
        WindowRectOp (tempwin, 2, 0, 0, 0, 0, 0xFFFFFF)  -- fill with white

        -- draw the pie showing amount of cooldown
        WindowCircleOp (tempwin, 5, -10, -10, 38, 38,   -- pie
              0x000000, 5, 0,   -- no pen
              0x000000, 0,      -- solid brush, black
              14, 0,            -- from 12 o'clock position
              endx, endy)

        -- turn pie shape into an image
        WindowImageFromWindow(win, "mask", tempwin)

        -- blend in (darken mode) with 50% opacity
        WindowBlendImage(win, "mask", 
                         3, 3, 31, 31,  -- rectangle
                         1, 0.3)       -- mode and opacity
      end -- if

      if tonumber(AffectDuration[i]) < 10 then
        offset = 9
      elseif tonumber(AffectDuration[i]) < 100 then
        offset = 5
      else -- two digits
        offset = 1
      end -- if

      if tonumber(AffectDuration[i]) < 0 then
        -- draw an infinity symbol
        outlined_text (colour, win, "O", 6, 4, 21)
        outlined_text (colour, win, "O", 6, 9, 21)
        -- go over the first 'O' again, removing the outline from the second 'O'
        WindowFont(win,'f','Times New Roman',6,1,0,0,0)
        WindowText(win,'f',"O",4,21,0,0,colour,0)
      else -- write the duration
        outlined_text (colour, win, AffectDuration[i], 6, 4, 21)
      end -- if

      -- show the window
      WindowShow (win, true)

      -- create a hotspot over the timer
      WindowAddHotspot(win, "hs_affect_"..i, 0, 0, 34, 34, "", "", "", "", "", AffectName[i], 1, 0)
    end -- if
  end -- for

end -- draw_affects


      	-- window functions
	function Draw(win)
		-- miniwin background and outline
		WindowRectOp(win.id, miniwin.rect_fill , 0, 0, win.width, win.height, ColourNameToRGB(window.backgroundColor))	
		WindowRectOp(win.id, miniwin.rect_3d_rect , 0, 0, win.width, win.height, ColourNameToRGB(window.borderColor), ColourNameToRGB(window.borderColor))				
		
		-- resize bars
		WindowLine(win.id, win.width-3,  win.height-2, win.width-2, win.height-3, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-4,  win.height-2, win.width-2, win.height-4, ColourNameToRGB(window.backgroundColor), 0, 1)
		WindowLine(win.id, win.width-6,  win.height-2, win.width-2, win.height-6, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-7,  win.height-2, win.width-2, win.height-7, ColourNameToRGB(window.backgroundColor), 0, 1)
		WindowLine(win.id, win.width-9,  win.height-2, win.width-2, win.height-9, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-10, win.height-2, win.width-2, win.height-10, ColourNameToRGB(window.backgroundColor), 0, 1)
		WindowLine(win.id, win.width-12, win.height-2, win.width-2, win.height-12, ColourNameToRGB(window.borderColor), 0, 2)
		WindowLine(win.id, win.width-13, win.height-2, win.width-2, win.height-13, ColourNameToRGB(window.backgroundColor), 0, 1)
		
      -- Where the magic happens. Draw all the things!
      local line = 0
      local total = 0

      for k, v in pairs(bloot) do
         total = bloot["Kills"]
      end
      
      for k, v in spairs(bloot, function(t,a,b) return t[a] > t[b] end) do
         WindowText(win.id, win.font, string.format("%-10s", k), 5, line * (win.fontSize+2), 0, 0, ColourNameToRGB(blootLookup[k]), true)
         WindowText(win.id, win.font, string.format(": %i (%.3f%%)", v, (v/total)*100), 5+(win.fontSize*10), line * (win.fontSize+2), 0, 0, ColourNameToRGB("silver"), true)
         line = line + 1
      end
	end	
   

	function InitializeWindow()
		WindowCreate(window.id, window.left, window.top, window.width, window.height, miniwin.pos_center_all, miniwin.create_keep_hotspots, ColourNameToRGB(window.backgroundColor))
		WindowFont(window.id, window.font, window.fontFamily, window.fontSize, false, false, false, false, 1, 0)
		WindowPosition(window.id, window.left, window.top, miniwin.pos_stretch_to_view, miniwin.create_absolute_location)	

		CreateHotSpots()
		
		if (window.show) then
			WindowShow(window.id, window.show)				
			if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
				CallPlugin(z_order_plugin, "boostMe", window.id)
			end
			Draw(window)
		end	
	end
	
	function DeleteWindow()
		WindowDelete(window.id)
   end

   function toggleWindow()
      if window.show == true then
         HideWindow()
         ColourNote("silver", "", "Bonus loot mini window has been ", "red", "", "DISABLED")
      else
         ShowWindow()
         ColourNote("silver", "", "Bonus loot mini window has been ", "lime", "", "ENABLED")
      end
   end
	
	function ShowWindow()
		window.show = true
		WindowShow(window.id, true)
		if (IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
			CallPlugin(z_order_plugin, "boostMe", window.id)
		end
		Draw(window)
		SaveWindow()	
	end
	
	function HideWindow()
		window.show = false
		WindowShow(window.id, false)
		Draw(window)
		SaveWindow()
	end	
	
	function SaveWindow()
		SetVariable("window", serialize.save_simple(window))
	end	
	
	function SetWindowDefaults()
		window = {
			id = "window_" .. GetPluginID(),
			top = 10,
			left = 10,
			width = 200,
			height = 50,
			show = true,
			font = "defaultFont",
			fontFamily = "Fixedsys",
			fontSize = 9,
			fontColor = "white",
			borderColor = "lightgray",
			backgroundColor = "black"
		}
	end
	
	function ResetWindow()
		SetWindowDefaults()		
		SaveWindow()	
		InitializeWindow()				
      Draw(window)
      ColourNote("silver", "", "Bonus loot mini window position/etc has been reset.")
	end
	
	function CreateHotSpots()
		WindowDeleteAllHotspots(window.id)
	
		WindowAddHotspot(window.id, "DragArea", 0, 0, window.width-13, window.height-13, 
			"", "", "", "", "mouseup", "Drag to move", miniwin.cursor_both_arrow, 0)
		WindowDragHandler(window.id, "DragArea", "dragmove", "dragrelease", 0)	

		WindowAddHotspot(window.id, "DragAreaBottom", 0, window.height-13, window.width-13, window.height, 
			"", "", "", "", "mouseup", "Drag to move", miniwin.cursor_both_arrow, 0)
		WindowDragHandler(window.id, "DragAreaBottom", "dragmove", "dragrelease", 0)	

		WindowAddHotspot(window.id, "DragAreaRight", window.width-13, 0, window.width, window.height-13, 
			"", "", "", "", "mouseup", "Drag to move", miniwin.cursor_both_arrow, 0)
		WindowDragHandler(window.id, "DragAreaRight", "dragmove", "dragrelease", 0)			
		
		WindowAddHotspot(window.id, "Resize", 
			window.width-13, window.height-13, window.width-2, window.height-2,
			"", "", "", "", "mouseup", "Drag to resize", miniwin.cursor_nw_se_arrow, 0)
		WindowDragHandler(window.id, "Resize", "resizemove", "resizerelease", 0) 
	end
	
	-- Handlers
	function dragmove(flags, hotspot_id)							
		if (not dragStart) then
			dragStart = {
				x = WindowInfo(window.id, 14),
				y = WindowInfo(window.id, 15),
			}
		end		
		
		WindowPosition(window.id, 
						WindowInfo (window.id, 17) - dragStart.x, 
						WindowInfo (window.id, 18) - dragStart.y, 
						miniwin.pos_stretch_to_view, 
						miniwin.create_absolute_location)
	end

	function dragrelease(flags, hotspot_id)		
		window.left = WindowInfo(window.id, 10)
		window.top = WindowInfo(window.id, 11)
		
		dragStart = nil
		
		SaveWindow()
	end
	
	function resizemove(flags, hotspot_id) 
		window.width = WindowInfo(window.id, 17) - WindowInfo(window.id, 10)
		window.height = WindowInfo(window.id, 18) - WindowInfo(window.id, 11)
		
		WindowResize(window.id, window.width, window.height, ColourNameToRGB("gray"))
		WindowShow(window.id, true)
	end -- dragmove

	function resizerelease(flags, hotspot_id)
		SaveWindow()
				
		CreateHotSpots()
		
		Draw(window)
	end -- dragrelease
	
	function mouseup(flags, hotspot_id)		
		if (bit.band(flags, miniwin.hotspot_got_rh_mouse) ~= 0) then
			local result = WindowMenu(window.id, 
				WindowInfo(window.id, 14),
				WindowInfo(window.id, 15),
				"Bring to front|Send to back")		
			
			if (result ~= "" and IsPluginInstalled(z_order_plugin) and GetPluginInfo(z_order_plugin, 17)) then
				if (result == "Send to back") then 
					CallPlugin(z_order_plugin, "dropMe", window.id)
				else
					CallPlugin(z_order_plugin, "boostMe", window.id)
				end
			end
		end
	end

]]>
</script>


</muclient>