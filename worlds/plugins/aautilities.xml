<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Saturday, June 18, 2016, 1:09 PM -->
<!-- MuClient version 4.93 -->

<!-- Plugin "AAUtilities" generated by Plugin Wizard -->

<muclient>
<plugin
   name="AAUtilities"
   author="Neurrone"
   id="3f75c8d03d74153d0a62387c"
   language="Lua"
   purpose="Broadcasts events such as information from KXWT to other plugins"
   save_state="y"
   date_written="2016-06-18 13:06:36"
   requires="4.75"
   version="1.12"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<triggers>
  <trigger
   enabled="y"
   match="^kxwt_area (?P<areaNum>[0-9-]+) (?P<areaName>[^\r\n]*)$"
   regexp="y"
   script="onKxwtArea"
   send_to="12"
   sequence="99"
  >
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   keep_evaluating="y"
   match="kxwt_*"
   script="onKxwt"
   send_to="14"
   sequence="100"
>
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^(?:A surge of power flows from (.*) into .*\.|(.*) looks about dazedly, but is whole once again\.|(.*) suddenly appears out of thin air\!|(.*) utters the words, '.*'|(.*) appears out of a flickering blue glow\.|(.*) appears in the middle of the room\.|(.*) is awakened by the noise\.|(.*) sits down and rests\.|(.*) stops resting, and stands up\.|(.*) goes to sleep\.|(.*) wakes up and starts resting\.|(.*) stops resting, and stands up\.|(.*) arrives from .*|You link hands with (.*) to the .*\.|(.*) leads the group in the casting of a spell\.\.\.|(.*) fails in casting the spell .*|(.*) casts a spell.*|(.*) goes berserk in battle\!|(.*)'s force shield slowly dissipates\.|(.*) suddenly appears more trustworthy and attractive\.|(.*)'s muscles magically fill out as artificial strength courses through .* body\.|(.*)'s muscles magically deflate, and return to normal\.|(.*) suddenly appears less trustworthy and attractive than a moment ago\.|(.*) is surrounded by a strong force shield\.|(.*) fades slowly out of existence\.|(.*) slowly fades into existence\.|(.*) makes a shallow cut on its arm, and paints .* with .* blood\.|(.*) rushes to aid (.*)\!|(.*) heroically rescues (.*)\!|(.*) (?:rescues you and takes over the|rushes to your side in) battle\!|(.*) rushes forward to (?:defend|protect) you\!|(.*) is mortally wounded, and will die soon if not aided\.|\( \w+\)\**(.*) is.*here.*|(.*) (?:glows with a bright light\!|is surrounded with a dark black aura\.)|(.*) is engulfed in a writhing mass of biting ethereal mouths\!|A beautiful web of blazing .* fire bursts forth from (.*) and hits (.*), setting .* on fire\!|(.*) is on fire\!|(.*) is blasted by a.*bolt of lightning\!|A ball of .* lightning crackles as it fries (.*)\!|(.*)\! taps .* life, and (?:a blood red winged demon flaps|a swarm of blood red demons fly) quickly toward (.*)\!|(.*) (?:annoys|scratches|hits|injures|wounds|mauls|decimates|devastates|maims|MUTILATES|DISMEMBERS|DISEMBOWELS|MASSACRES|\*\*\* MASSACRES \*\*\*|\*\*\* DEVASTATES \*\*\*|\*\*\* OBLITERATES \*\*\*|\*\*\* DEMOLISHES \*\*\*|\*\*\* DESTROYS \*\*\*|\*\*\* ANNIHILATES \*\*\*) (.*).|(.*) starts (?:carving|carving a rune) on .*\.|(.*) starts drawing on .* in a flowing, measured script\.|(.*) utters a strange low call, weaved into a short spell\.|(.*) releases .* from .* control\.|(.*) (?:starts|stops) following (.*)\.)$"
   regexp="y"
   script="onPotentialMemberPresent"
   send_to="14"
   sequence="1"
  >
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^(?:kxwt_pdeath (.*)|(.*).*disappears\.|The air snaps as (.*) abruptly disappears\.|(.*) is rescued from the brink of death by a higher power\!|(.*) vanishes into a flickering red glow\.|(.*) is left behind\.|(.*) disappears in a rather large mushroom cloud\.)$"
   regexp="y"
   script="onPotentialMemberAbsent"
   send_to="14"
   sequence="100"
  >
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   match="^(You don't see any other players here in the room with you\.|Players in the room with you\:)$"
   name="playerCommandHeader"
   regexp="y"
   script="onPlayerCommandHeader"
   send_to="14"
   sequence="100"
  >
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="n"
   match="^([a-zA-Z]+)$"
   name="playerCommandBody"
   regexp="y"
   script="onPlayerCommandBody"
   send_to="14"
   sequence="100"
  >
  </trigger>
</triggers>

<aliases>
  <alias
   script="ui"
   match="aau*"
   enabled="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  </alias>
</aliases>

<script>
<![CDATA[

require "serialize"
require "tprint"
require "wait"
version = "1.12"
showKxwtData = false
isDebuggingEvents = false -- shows the contents of events being broadcasted
isDebuggingTracking = false -- shows group tracking updates

-- when broadcasting events, the event type is distinguished by a numberic ID
-- this table contains a sequence of strings for the event types supported
-- during plugin initialization, additional keys will be added to this table to form a reverse index (i.e, getting the number corresponding to a string event type)
eventTypes = { "name", "prompt", "position", "gold", "exp", "expcap", "spellup", "spelldown", "groupPrompt", "playerDeath", "mobDeath", "otherPlayerDeath"}

constants = {
  terrain = {[0] = "NOTSET", "BUILDING", "TOWN", "FIELD", "LFOREST", "TFOREST", "DFOREST", "SWAMP", "PLATEAU", "SANDY", "MOUNTAIN", "ROCK", "DESERT", "TUNDRA", "BEACH", "HILL", "DUNE", "JUNGLE", "OCEAN", "STREAM", "RIVER", "UNDERWATER", "UNDERGROUND", "AIR", "ICE", "LAVA", "RUINS", "CAVE", "CITY", "MARSH", "WASTELAND" },
  walkdir = {[0] = "n", "e", "s", "w", "ne", "se", "sw", "nw", [20] = "u", [30] = "d"},
  directionAbbreviations = { north = "n", northeast = "ne", east = "e", southeast = "se", south = "s", southwest = "sw", west = "w", northwest = "nw", up = "u", down = "d" }
}
player = {
  context = "", name = "", position = "standing",
  currentHP = 0, maxHP = 0, currentMN = 0, maxMN = 0, currentMV = 0, maxMV = 0,
  actionNum = 0, exp = 0, expcap = 0, gold = 0,
  spells = {},
  target = { condition = -1, name = "", gender = ""},
  location = { areaNum = 0, areaName = "", roomNum = 0, roomName = "", terrainName = constants.terrain[0], terrainNum = 0, isWaypoint = false, isNocast = false }
}
--prevRoomNum = 0 -- for determining whether look was typed
group = {} -- info about the player's group, if any
membersPresent = {} -- array of group members known to be present

kxwtGroupPromptInfo = {} -- it is easier to process all incoming kxwt_group prompt data all at once. This is just temporary storage for this

function OnPluginInstall ()
  EnableTrigger("playerCommandBody", 0)
  for k,v in ipairs(eventTypes) do
    eventTypes[v] = k
  end
end

-- returns the serialized player table as a string
-- the table can be restored by using the loadstring function
function getPlayerInfo() 
  return serialize.save_simple(player)
end

function getGroupInfo()
  return serialize.save_simple(group)
end

-- callbacks when various events occur
--[[
this is called any time there is a match on the trigger ^kxwt_(.*)$. The only exception is if we detect kxwt_area (see below).

This is the send when the player types look, or moves to a new location without walking:
kxwt_rvnum 11761
kxwt_terrain 1
kxwt_waypoint
kxwt_area -1 

When the start of the block (kxwt_rvnum) is detected, onKxwtRvnum has to reset player.location.isWaypoint to false. If this room is actually a waypoint, then onKxwtWaypoint resets this back to true. Same with nocast
The block ends with kxwt_area. If the player walked/retreated, an additional kxwt_walkdir line is present just below kxwt_area
If the player climbed, walkdir is not sent - instead, the following line will be present after kxwt_area:
You begin your climb upward.
Additional complex processing is also required to get the room's name.
So onKxwtArea is called instead on the generic onKxwt function to handle kxwt_area, and the detection of whether kxwt_walkdir or climbing is present. As all location info is sent at once, this requires onKxwtArea to detect the end of the block and to broadcast the event.
--]]

function onKxwt(name, line, wildcards)
  if showKxwtData then
    print(line)
  end
  
  local str = wildcards[1] -- only 1 wildcard due to how trigger is written
  local tokens = utils.split(str, " ")
  local infoType = tokens[1] -- type of KXWT data, e.g, this is name if this triggered on kxwt_myname Victorious
  
  if infoType == "action" then
    local action = string.match(tokens[2], "^([0-9-]+)$")
    if action then
      onKxwtAction(tonumber(action))
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "context" then
    local context = string.match(str, "^context (.*)$")
    if context then
      onKxwtContext(context)
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "exp" then
    local exp = string.match(tokens[2], "^([0-9-]+)$")
    if exp then
      onKxwtExp(tonumber(exp))
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "expcap" then
    local expcap = string.match(tokens[2], "^([0-9]+)$")
    if expcap then
      onKxwtExpcap(tonumber(expcap))
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "fighting" and tokens[2] ~= "-1" then
    local mobPercent, gender, mobName = string.match(line, "^kxwt_fighting ([0-9-]+) ([a-zA-Z]+) (.*)$")
    if mobPercent and gender and mobName then
      onKxwtFighting(tonumber(mobPercent), gender, mobName)
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "fighting" and tokens[2] == "-1" then
    onKxwtFighting(-1, "", "")
  elseif infoType == "gdeath" then
    local memberName = string.match(str, "^gdeath (.*)$")
    if memberName then
      onKxwtGdeath(memberName)
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "gold" then
    local gold = string.match(tokens[2], "^([0-9-]+)$")
    if gold then
      onKxwtGold(tonumber(gold))
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "mdeath" then
    local mobName = string.match(str, "^mdeath (.*)$")
    if mobName then
      onKxwtMdeath(mobName)
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "myname" then
    local name = string.match(str, "^myname (.+)$")
    if name then
      onNameReceipt(name)
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "nocast" then
    onKxwtNocast()
  elseif infoType == "pdeath" then
    local playerName = string.match(str, "^pdeath (.+)$")
    if playerName then
      onKxwtPdeath(playerName)
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "position" then
    local position = string.match(str, "^position (.+)$")
    if position then
      onKxwtPosition(position)
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "prompt" then
    local currentHP, maxHP, currentMN, maxMN, currentMV, maxMV = string.match(str, "^prompt ([0-9-]+) ([0-9-]+) ([0-9-]+) ([0-9-]+) ([0-9-]+) ([0-9-]+)$")
    if currentHP and maxHP and currentMN and maxMN and currentMV and maxMV then
      onKxwtPrompt(tonumber(currentHP), tonumber(maxHP), tonumber(currentMN), tonumber(maxMN), tonumber(currentMV), tonumber(maxMV))
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "ydeath" then
    local mobName = string.match(str, "^ydeath (.*)$")
    if mobName then
      onKxwtYdeath(mobName)
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
-- group related
  elseif infoType == "group_start" then
    onKxwtGroupStart()
  elseif infoType == "group" then
    local currentHP, maxHP, currentMN, maxMN, currentMV, maxMV, tag, name = string.match(str, "^group ([0-9-]+) ([0-9-]+) ([0-9-]+) ([0-9-]+) ([0-9-]+) ([0-9-]+) ([A-Z?]+) (.+)$") -- todo: check if the ? tag matches this
    if currentHP and maxHP and currentMN and maxMN and currentMV and maxMV and name and tag then
      onKxwtGroupPromptt(tonumber(currentHP), tonumber(maxHP), tonumber(currentMN), tonumber(maxMN), tonumber(currentMV), tonumber(maxMV), tag, name)
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "group_end" then
    onKxwtGroupEnd()
-- movement and location-related info
  elseif infoType == "rvnum" then
    local rvnum = string.match(tokens[2], "^([0-9-]+)$")
    if rvnum then
      onKxwtRvnum(tonumber(rvnum))
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "terrain" then
    local terrain = string.match(tokens[2], "^([0-9-]+)$")
    if terrain then
      onKxwtTerrain(tonumber(terrain))
    else
      print("Invalid kxwt data (tell Vic): "..line)
    end
  elseif infoType == "waypoint" then
    onKxwtWaypoint()
  end
end

function onKxwtAction(actionNum)
  player.actionNum = actionNum
  broadcastEvent({type = "action", action = actionNum})
end

function onKxwtContext(context)
  player.context = context
  broadcastEvent({type = "context", context = context})
end

function onKxwtExp(exp)
  player.exp = exp
  broadcastEvent({type = "exp", exp = exp})
end

function onKxwtExpcap(expcap)
  player.expcap = expcap
  broadcastEvent({type = "expcap", expcap = expcap})
end

function onKxwtFighting(healthPercent, gender, name)
  player.target = {condition = healthPercent, gender = gender, name = name}
  broadcastEvent({type = "fighting", name = name, gender = gender, condition = healthPercent})
end

function onKxwtGdeath(minionName)
  broadcastEvent({type = "gdeath", name = minionName})
end

function onKxwtGold(gold)
  player.gold = gold
  broadcastEvent({type = "gold", gold = gold})
end

function onKxwtMdeath(mobName)
  broadcastEvent({type = "mdeath", name = mobName})
end

-- this is called either by kxwt_myname receipt, or when we see a kxwt_group line that has a tag of 'x'.
function onNameReceipt(name)
  if name ~= player.name then -- either player.name is the default empty string, or the user has switched chars
  -- remove the old player's name from being present, if necessary
    if isPresent(player.name) then removeMemberPresent(player.name) end
    player.name = name
    if isPresent(name) == false then
      addMemberPresent(name)
      -- table.insert(membersPresent, name)
    end
    
    broadcastEvent({type = "name", name = name})
  end
end

function onKxwtPdeath(playerName)
  broadcastEvent({type = "pdeath", name = playerName})
end

function onKxwtPosition(pos)
  player.position = pos
  broadcastEvent({type = "position", position = pos})
end

function onKxwtPrompt(currentHP, maxHP, currentMN, maxMN, currentMV, maxMV)
  player.currentHP = currentHP
  player.maxHP = maxHP
  player.currentMN = currentMN
  player.maxMN = maxMN
  player.currentMV = currentMV
  player.maxMV = maxMV
  local event = {type = "prompt", currentHP = currentHP, maxHP = maxHP, currentMN = currentMN, maxMN = maxMN, currentMV = currentMV, maxMV = maxMV}
  broadcastEvent(event)
end

function onKxwtYdeath(minionName)
  broadcastEvent({type = "ydeath", name = minionName})
end

-- group-related callbacks
--[[
When kxwt_group_start is received, we need to reset the current group info so that we get the most up-to-date info to follow.
On receipt of kxwt_group_end, this information is broadcasted, all at once.
--]]

function onKxwtGroupStart() 
  kxwtGroupPromptInfo = {} -- reset
  group = {} -- reset
end

-- at this step, we can parse the tag string, but it is difficult to determine for minions, which player it belongs to 
-- hence we store it in first, then finish the processing at kxwt_group_end
function onKxwtGroupPromptt(currentHP, maxHP, currentMN, maxMN, currentMV, maxMV, tag, name)
--[[ 
tag is a string that always contains at least 1 character. 
The first char is always one of {'P', 'X', 'M', 'O', '?'}.
If the group member is a leader, there is an 'L' somewhere after the first character.
If the group member is tanking, there is a 'T' somewhere after the first character.
--]]

  local memberType
  local firstChar = string.sub(tag, 1, 1)
  
  if firstChar == 'X' then
    memberType = "self"
    onNameReceipt(name)
  elseif firstChar == 'P' then
    memberType = "player"
  elseif firstChar == 'M' then
    memberType = "yourMinion"
  elseif firstChar == 'O' then
    memberType = "otherMinion"
  elseif firstChar == '?' then
    memberType = "unknown"
  end
  
  if memberType == nil then
    assert(memberType, "Could not determine group member type for "..name)
  end
  
  local isLeader, isTank
  isLeader = string.find(tag, "L") -- this is nill when the string is not found, contains the start index of the match otherwise
  isTank = string.find(tag, "T")
  
  if isLeader then -- if this contains a number, it evaluates as true
    isLeader = true
  else
    isLeader = false
  end
  
  if isTank then -- if this contains a number, it evaluates as true
    isTank = true
  else
    isTank = false
  end
-- insert a table containing parsed info into the kxwtGroupPrompt table
  table.insert(kxwtGroupPromptInfo, {currentHP = currentHP, maxHP = maxHP, currentMN = currentMN, maxMN = maxMN, currentMV = currentMV, maxMV = maxMV, memberType = memberType, isLeader = isLeader, isTank = isTank, isPresent = isPresent(name), name = name})
end

function onKxwtGroupEnd() 
-- go down the list, adding info about players to the group table. Minions are hard to handle right now
  for i,v in ipairs(kxwtGroupPromptInfo) do
    if v.memberType == "self" or v.memberType == "player" then
      table.insert(group, v)
    end
  end
  
  removeUngroupedMembersFromPresentList()
  broadcastEvent({type = "groupPrompt", group = group})
end

-- adds a group member to the present list
-- returns true on success, false if already present
function addMemberPresent(memberName)
  local index = searchTable(membersPresent, memberName)
  if index then
    return false
  end
  
  table.insert(membersPresent, memberName)
  broadcastEvent({type = "memberPresent", name = memberName})
  if isDebuggingTracking then
    print("Added "..memberName.." to present list.")
  end
  return true
end

-- removes a group member from the present list
-- returns true on success, false if the member could not be removed
function removeMemberPresent(memberName)
  local index = searchTable(membersPresent, memberName)
  if index then
    table.remove(membersPresent, index)
    broadcastEvent({type = "memberAbsent", name = memberName})
    if isDebuggingTracking then
      print("Removed "..memberName.." from present list.")
    end
    
    return true
  end
  
  return false
end

-- this should be called periodically, e.g after every kxwt_group_end
function removeUngroupedMembersFromPresentList() 
  for i, member in ipairs(membersPresent) do
    if isGrouped(member) == false then
      removeMemberPresent(member)
    end
  end
end

-- this script is called by the trigger that detects the presence of members
function onPotentialMemberPresent(name, line, wildcards) 
  for i, member in ipairs(wildcards) do
-- we test for the empty string because the trigger is a gigantic regex with tonnes of blank wildcards
    if member ~= "" and isGrouped(member) and isPresent(member) == false then
      addMemberPresent(member)
    end
  end
end

-- this script is called by the trigger that detects the absence of members
function onPotentialMemberAbsent(name, line, wildcards) 
  for i, member in ipairs(wildcards) do
    if member ~= "" and isGrouped(member) and isPresent(member) and member ~= player.name then
      removeMemberPresent(member) -- ensure that the player himself is never removed from this list
    end
  end
end

-- we can think of the player command of having a header, and a body of n lines, where n is the number of players if any are present
function onPlayerCommandHeader(name, line, wildcards)
-- this is called when either "You don't see any other players here in the room with you." or "Players in the room with you:"
-- in both cases, we want to remove all player members present, except the player/user himself  
  local copy = membersPresent
  for i, player in ipairs(copy) do
    if player ~= player.name and isPresent(player) then
      removeMemberPresent(player)
    end
  end
  
  if line == "Players in the room with you:" then
    EnableTrigger("playerCommandBody", 1)
    wait.make(function()
      wait.time(0.2)
      EnableTrigger("playerCommandBody", 0)
    end)
  end
end

function onPlayerCommandBody(name, line, wildcards)
-- for some reason, the players listed in the body of the player command are all lower-cased. So we need to account for this
  local playerName = string.lower(wildcards[1])
-- we can't use the normal isGrouped function because that is case sensitive
  for i, member in ipairs(group) do
    if string.lower(member.name) == playerName then
      addMemberPresent(member.name) -- don't use playerName because its been lower-cased
    end
  end
end

function capitalizeFirstChar(str)
    return (str:gsub("^%l", string.upper))
end

-- location and movement-related callbacks
function onKxwtRvnum(roomNum)
  player.location.isWaypoint = false
  player.location.isNocast = false
  -- prevRoomNum = player.location.roomNum -- store previous room number so we can compare the new and old one. If they are the same, then no movement occured (e.g, player typed look)
  player.location.roomNum = roomNum
end

function onKxwtTerrain(terrainNum)
  player.location.terrainNum = terrainNum
  if terrainNum >= 0 and terrainNum <= #constants.terrain then
    player.location.terrainName = constants.terrain[terrainNum]
  else
    player.location.terrainName = "UNKNOWN"
  end
end

function onKxwtWaypoint()
  player.location.isWaypoint = true
end

function onKxwtNocast()
  player.location.isNocast = true
end

function onKxwtArea(name, line, wildcards)
  if showKxwtData then
    print(wildcards[0])
  end
  
  player.location.areaNum = tonumber(wildcards["areaNum"])
  player.location.areaName = wildcards["areaName"]
  player.location.roomName = nil
  
  -- figure out the walk/climb direction, as well as room title
  local  roomName
  
  wait.make(function()
    local  climbdir, walkdir, roomName, isFarsee = waitForRoomInformation()
    if not isFarsee then
      validateAndBroadcastLocationInfo( climbdir, walkdir, roomName)
    end
  end)
end

local isNonRoomTitlePattern = "kxwt|You have left .+|You are now entering .+|WARNING - .+|You are blind.|You begin your climb .+|You look at .+|You follow .+.|You start helping .+ organize the retreat...|You .*|.+ has summoned you!|.+ has summoned you into .+ group!|The air is filled with a magical darkness|You are engulfed in darkness.|.+ (flies|leaves|swims|climbs) .+|.+ begins .+ climb .+.|.+ tells the clan, '.*'|\\s+|zchn:.+|mapmove.+|Somewhere very dark|.+ utters the words, .+|.+ tells the group, .+|The painting expands, growing larger and larger until it fills your view.|.+ scans the area to see who is around.|.+ vanishes into a flickering .+ glow.|.+ yells, .+|This is a .+|spfl.+|A .+ glow surrounds .+, then flows outward.|.*(?:(?i)an evil looking snowman|(?:a lesser|a|an|a greater) (?:fire|fire pillar|ice|lightning|crystal) elemental|an (?:incarnate|aspect)|a (?:clay man|bone guardian|flesh beast|wood woad|metal construct|winged red imp|straw man|skeleton|skeletal (?:spider|mage|knight|lich)|ghoul|shadow fiend|mummy|vampire)|(?:an energetic green|a black, horned|an azure blue|an ebony scaled) demon|Vampiric vines|a (?:clutch of poison ivy vines|porcupine|coyote|feral boar|gigantic catfish|shambling mound|swarm of rats|hyena|wolf|mantis shrimp|stingray|liveoak|viper|tall stag|black bear|baboon|massive elk|brown bear|blue shark|cloud of bats|mountain lion|black panther|winter wolf|gigantic moose|polar bear|crocodile|kraken|shambling bone man)|an (?:earth wall|electric eel|ape|alligator|ancient oak tree|abominable yeti)).*|into existence above them.  Staring into it, you see an image...|--------------------|Location - .*"
local isNonRoomNameRegex = rex.new ("^("..isNonRoomTitlePattern..")")
local roomNameOrClimbdirRegex = rex.new("^(You begin your climb (?P<climbdir>.+)ward.|(?!"..isNonRoomTitlePattern.."))")
local isObjectOrMobInRoomRegex = rex.new("\\((?:[-0-9+ ]+)\\).+")
local isExitsRegex = rex.new("\\[Exits: (?P<exits>.+?)\\](| \\[Doors: (?P<doors>.+)\\])")
-- this function returns 3 values, walkdir, climbdir and roomName
-- either walkdir or climbdir could be nil if we detect that the movement wasn't through walking or climbing
function waitForRoomInformation()
  local climbdir, walkdir, roomName
  local isFarsee = false
  while not roomName do
    local response, wildcards = wait.regexp("^(kxwt_walkdir (?P<walkdir>[0-9]+)|You begin your climb (?P<climbdir>.+)ward.|mapmove(?P<roomNameFromZmap>.+)|into existence above them.  Staring into it, you see an image...|(?!"..isNonRoomTitlePattern.."))")
    if response and response ~= "" then
      if wildcards.walkdir and wildcards.walkdir ~= "" then
        walkdir = constants.walkdir[tonumber(wildcards.walkdir)]
      elseif wildcards.climbdir and wildcards.climbdir ~= "" then
        -- if the climb direction is one of the normal cardinal directions, send its abbreviation
        -- otherwise, send the full string
        climbdir = constants.directionAbbreviations[wildcards.climbdir] or wildcards.climbdir
      else -- we may have a room name
        local candidateRoomName = response
        if candidateRoomName == "into existence above them.  Staring into it, you see an image..." then
          isFarsee = true
        end
        if isObjectOrMobInRoomRegex:match(candidateRoomName) or isExitsRegex:match(candidateRoomName) then
          --print("breaking on", candidateRoomName)
          break -- we've missed the room title, since we're now seeing the room's contents or exits
        end
        local isZmapBeingUsed = wildcards.roomNameFromZmap ~= nil and wildcards.roomNameFromZmap ~= ""
        if isZmapBeingUsed then
          candidateRoomName = wildcards.roomNameFromZmap
        end
        -- since most of the inaccurate room names that we capture occur in group, and since they involve group member's name being present
        -- if a group member's name is found in the response, then this cannot be the room title.
        local groupMemberNameFoundInStr = false
        for k, v in pairs(group) do
          if string.match (candidateRoomName, v.name) then
            groupMemberNameFoundInStr = true
            break
          end
        end        
        
        if not groupMemberNameFoundInStr then
          roomName = candidateRoomName
        end
      end
    end
  end
  
  return  climbdir, walkdir, roomName
end

function validateAndBroadcastLocationInfo(climbdir, walkdir, roomName)
  if roomName == "" or  (roomName and isNonRoomNameRegex:match(roomName)) then
    roomName = nil
  end
  player.location.roomName = roomName
  --[[
  print("room name:", roomName)
  if walkdir then
    print("walked", walkdir)
  end
  if climbdir then
    print("Climbed", climbdir)
  end
  --]]
  broadcastEvent({type = "location", location = player.location, climbdir = climbdir, walkdir = walkdir})
end

-- broadcasts information about an event to other plugins
function broadcastEvent(eventData) 
  local serializedEvent = serialize.save_simple(eventData)
  if isDebuggingEvents then
    print("sending event: "..serializedEvent)
  end
--[[
  local eventId = eventTypes[eventName]
  assert(eventId ~= nil)
--]]
  BroadcastPlugin(1, serializedEvent)
end

-- implements the UI
function ui(name, line, wildcards)
  local str = string.lower(Trim(wildcards[1]))
  local isHelpRequested = str == ""
  
  if isHelpRequested then
    showHelp()
    return
  end
  
  local tokens = utils.split(str, " ")
  local command = tokens[1]
  if command == "kxwt" and tokens[2] == "on" then
    showKxwtData = true
    print("Incoming KXWT data will now be shown.")
  elseif command == "kxwt" and tokens[2] == "off" then
    showKxwtData = false
    print("Incoming KXWT data will no longer be shown.")
  elseif command == "debugevents" and tokens[2] == "on" then
    isDebuggingEvents = true
    print("Event broadcasts will now be shown.")
  elseif command == "debugevents" and tokens[2] == "off" then
    isDebuggingEvents = false
    print("Event broadcasts will no longer be shown.")
  elseif command == "debugtracking" and tokens[2] == "on" then
    isDebuggingTracking = true
    print("Group tracking updates will now be shown.")
  elseif command == "debugtracking" and tokens[2] == "off" then
    isDebuggingTracking = false
    print("Group tracking updates will no longer be shown.")
  elseif command == "group" then
    tprint(group) -- print out group table
  elseif command == "player" then
    tprint(player) -- print out players table
  elseif command == "tracking" then
    showTrackingList()
  elseif command == "changes" or command == "changelog" then
    showChangelog()
  else
    print("Invalid command.")
  end
  
end

function showHelp() 
print("AA Utilities "..version)
print([[by Neurrone

This plugin broadcasts events such as kxwt data to other plugins, which can listen for these events. This avoids duplicating common functionality like obtaining health/mana/mv info. Consult the readme for details. All options are non-persistent. All commands are case-insensitive, and prefixed by AAU.

Options:
]])

local showKxwtSetting = ""
if showKxwtData then
  showKxwtSetting = "on"
else
  showKxwtSetting = "off"
end

print("KXWT <on/off> - display incoming KXWT data. Currently "..showKxwtSetting..".")
print("Tracking - displays present group members (players only).")
print([[changes/changelog - displays the changelog.

Developer options:
]])

local debugEventSetting = ""
if isDebuggingEvents then
  debugEventSetting = "on"
else
  debugEventSetting = "off"
end

print("DebugEvents <on/off> - displays events being broadcasted. Currently "..debugEventSetting..".")

local debugTrackingSetting = ""
if isDebuggingTracking then
  debugTrackingSetting = "on"
else
  debugTrackingSetting = "off"
end

print("DebugTracking <on/off> - displays group tracking updates (players only). Currently "..debugTrackingSetting..".")
print([[Group - print the group table.
Player - display the player table.
]])
end

function showTrackingList()
  if #membersPresent > 0 then
    print(#membersPresent.." players present: ")
    print(unpack(membersPresent))
  else
    print("There is noone with you - you are probably not in a group.")
  end
end

function showChangelog() 
print([[Changelog

v1.12 (13 aug 2017)
1. Ignore kxwt location information when farseeing.

v1.11 (11 aug 2017)
1. Improve room name detection so that it either returns the correct result or fails when it is impossible to determine the room's name when using mush-z's zmap feature.
2. The room name algorithm now  terminates early if it detects receipt of mobs/objects in the room, or the exits line. This indicates failure to detect the room's name.

v1.10 (10 aug 2017)
Rewrote the room name detection heuristic, which should work much better now in groups. Highlights include using the names of  grouped players and all known minions in control list to prevent spurious room names due to spellcasting, combat etc.

v1.06 (7 aug 2017)
Prevent "somewhere very dark" from being used as room names.

v1.05 (5 Aug 2017)
prevent channel sends, and movement of group members from being misdetected as room titles.

v1.02 (4 Aug 2017):
Numerous improvements to room title detection.

v1.01 (31 Jul 2017):
Fix walk direction not being broadcasted in location updates.
Changed the API for events being sent on walking - this field may be nil now.
Add sending of the climbdir field if the player changed location by climbing.

v1.0:
Initial release
]])
end

-- useful misc functions

-- searches the supplied table for the specified value
-- returns: the index in the table where the value can be found, nil otherwise
function searchTable(t, value)
  assert(value, "value cannot be nill")
  for k, v in pairs(t) do
    if v == value then
      return k
    end
  end
  
  return nil
end

-- determines if the specified group member is present
function isPresent(memberName) 
  return searchTable(membersPresent, memberName) ~= nil
end

-- determines if the specified name is grouped
function isGrouped(memberName) 
  for i,v in ipairs(group) do
    if v.name == memberName then
      return true
    end
  end
  return false
end

]]>
</script>
</muclient>