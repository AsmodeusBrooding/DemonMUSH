<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>

<!-- Plugin "CopyScript" generated by Plugin Wizard -->

<!-- Made for Clan Demon -->


<muclient>
<plugin
   name="DemonMUSH_Kxwt_Handler"
   author="Demon"
   id="04d9e64f835453c045b427a7"
   language="Lua"
   purpose="Removes Kxwt spam"
   save_state="y"
   date_written="2019-01-04"
   requires="4.00"
   version="1.1"
   >

<description trim="y">
Removes KXWT spam from output

</description>

</plugin>
<triggers>
 <trigger
   enabled="y"
   match="^kxwt\_time (\d+) ([a-zA-Z]+) (\d+)\:(\d+) (am|pm)$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
atold1 = at1
at1 = "%3"
at2 = "%4"
at3 = "%5"
atd = "%2"
</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt\_waypoint$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
<send>
Sound("stop=all")
musicPlaying = false
</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt_emote (.*)$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="1"
  >
  <send>
Note("%1")
</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt\_group\_start$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
kplayers={}
kminions={}
kotherminions={}
kpcount = 0
</send>
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt\_group\_end$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
--
</send>
  </trigger>
   <trigger
 enabled="y"
 match="^kxwt_spellup (.*)"
regexp="y"
 send_to="14"
 sequence="99"
omit_from_output="y"
 >

 </trigger>
<trigger
 enabled="y"
 match="kxwt_audio *"
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
 </trigger>
<trigger
 enabled="y"
 match="kxwt_action *"
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
 </trigger>
<trigger
 enabled="y"
 match="Set it to NULL to delete."
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
 </trigger>
<trigger
 enabled="y"
 match="kxwt_rshort *"
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
 </trigger>
<trigger
 enabled="y"
 match="kxwt_id_start"
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
 </trigger>
<trigger
 enabled="y"
 match="kxwt_id_end"
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
 </trigger>

<trigger
 enabled="y"
 match="kxwt_sky *"
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
 </trigger>
<trigger
 enabled="y"
 match="kxwt_spst *"
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
 </trigger>
<trigger
 enabled="y"
 match="Your current channel prefix is now '[]'"
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_time (-{0,1}\d+) (\w+) (\w+)"
 regexp="y"
 sequence="100"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
 <trigger
 enabled="y"
 match="kxwt_fighting *"
 omit_from_output="y"
 omit_from_log="y"
 send_to="14"
 sequence="100"
 >
</trigger>
 <trigger
 enabled="y"
 match="kxwt_mdeath *"
 omit_from_output="y"
 omit_from_log="y"
 send_to="14"
 sequence="100"
 >
</trigger>
 <trigger
 enabled="y"
 match="kxwt_ydeath *"
 omit_from_output="y"
 omit_from_log="y"
 send_to="14"
 sequence="100"
 >
</trigger>
 <trigger
 enabled="y"
 match="kxwt_pdeath *"
 omit_from_output="y"
 omit_from_log="y"
 send_to="14"
 sequence="100"
 >
</trigger>
 <trigger
 enabled="y"
 match="^kxwt_spelldown (.*)"
regexp="y"
 send_to="14"
 sequence="99"
omit_from_output="y"
 >

 </trigger>
  <trigger
   enabled="n"
   match="^kxwt_walkdir (\d+)"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >

  </trigger>
   <trigger
   enabled="y"
   match="^kxwt_group (?P&lt;hp&gt;-?\d+) (?P&lt;mhp&gt;\d+) (?P&lt;mn&gt;-?\d+) (?P&lt;mmn&gt;\d+) (?P&lt;mv&gt;-?\d+) (?P&lt;mmv&gt;\d+) (?P&lt;tag&gt;\S+) (?P&lt;name&gt;.*)"
   omit_from_output="y"
   regexp="y"
   sequence="100"
  >
  </trigger>

  <trigger
   enabled="y"
   match="A blood red winged demon claws at *!"
   omit_from_output="y"
   regexp="n"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="A blood red winged demon bites *!"
   omit_from_output="y"
   regexp="n"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="^kxwt_rvnum (\d+)"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="kxwt_myname *"
   omit_from_output="y"
   regexp="n"
   send_to="14"
   sequence="100"
  >
<send>Send("localecho DemonMUSH v2.01b "..uid)</send>
  </trigger>
    <trigger
   enabled="y"
   match="DemonMUSH v* *"
   omit_from_output="y"
   regexp="n"
   send_to="14"
   sequence="100"
  >
  </trigger>
<trigger
   enabled="y"
   match="Dentin tells you, 'version'"
   omit_from_output="y"
   regexp="n"
   send_to="14"
   sequence="100"
  >
<send>Send("reply DemonMUSH v2.01 "..uid)</send>
  </trigger>
<trigger
   enabled="y"
   match="A terrible winged Demon tells you, 'version'"
   omit_from_output="y"
   regexp="n"
   send_to="14"
   sequence="100"
  >
<send>Send("reply DemonMUSH v1.44b "..uid)</send>
  </trigger>
<trigger
   enabled="y"
   match="Soth tells you, 'version'"
   omit_from_output="y"
   regexp="n"
   send_to="14"
   sequence="100"
  >
<send>Send("reply DemonMUSH v2.01b "..uid)</send>
  </trigger>
<trigger
   enabled="y"
   match="You reply to *, 'DemonMUSH v2.01b *'"
   omit_from_output="y"
   regexp="n"
   send_to="14"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   match="kxwt_supported"
   omit_from_output="y"
   sequence="100"
  >
  <send>set kxwt on
set cprefix ~R~H[]~O</send>
  </trigger>
<trigger
 enabled="y"
 match="kxwt_idle"
 omit_from_output="y"
 omit_from_log="y"
 sequence="100"
 >
<send>l</send>
 </trigger>
    <trigger
   enabled="y"
   match="kxwt_nocast"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>
nocastroom=true
</send>
</trigger>
 <trigger
   enabled="y"
   match="kxwt_expcap *"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>k_cap=tonumber("%1")</send>
  </trigger>
  <trigger
   enabled="y"
   match="kxwt_obj_zap *"
   omit_from_output="y"
   send_to="14"
   sequence="100"
  >
  <send>
print ZAPPED
</send>
  </trigger>
  <trigger
 enabled="y"
 match="^kxwt_prompt (-{0,1}\d+) (-{0,1}\d+) (-{0,1}\d+) (-{0,1}\d+) (-{0,1}\d+) (-{0,1}\d+)"
sequence="1"
regexp="y"
 send_to="14"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_area (-{0,1}\d+) (.*)"
sequence="3"
regexp="y"
 send_to="14"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_area -1\s*"
sequence="2"
regexp="y"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_exp (-{0,1}\d+)"
 script="k_exp"
sequence="1"
regexp="y"
 send_to="14"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_terrain (-{0,1}\d+)"
sequence="1"
regexp="y"
 send_to="14"
omit_from_output="y"
 omit_from_log="y"
 >
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_gold (-{0,1}\d+)"
sequence="1"
regexp="y"
omit_from_output="y"
omit_from_log="y"
send_to="14"
 >
 </trigger>
 <trigger
 enabled="y"
 match="kxwt_position *"
sequence="1"
omit_from_output="y"
omit_from_log="y"
send_to="14"
 >
</trigger>

----------------------------------------------------------
-- BRAG LAG STUFF
----------------------------------------------------------
 <trigger
   enabled="y"
   match="^\*pong\*$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
  Send("pang")
  </send>
  </trigger>

  <trigger
   enabled="y"
   match="^\*pingtime (\d+)\*$"
   omit_from_log="y"
   omit_from_output="y"
   regexp="y"
   send_to="14"
   sequence="100"
  >
  <send>
  lag = tonumber("%1")
  if lag &lt; 999.5 then
   lag = (math.floor(lag+0.5)).." ms"
  elseif lag &lt; 9999.5 then
   lag = (math.floor(lag/10+0.5)/100).." s"
  else
   lag = (math.floor(lag/100+0.5)/10).." s"
  end
  if lagbrag then
   Send(lagbrag.." I currently have a connection lag of "..lag..".")
   lagbrag = nil
  else
   Note("Lag: "..lag)
  end
  </send>
  </trigger>
 <trigger
 enabled="y"
 match="lagcheck"
 omit_from_output="y"
keep_evaluating="y"
 sequence="100"
 >
 </trigger>
------------------------------------------------------------------------------------
-- EXM STUFF
------------------------------------------------------------------------------------
<trigger
enabled="y"
match="^You spend (-{0,1}\d+) experience to give (-{0,1}\w+) (?:a gift of experience\.$|an anonymous gift\.$)"
regexp="y"
send_to="14"
   sequence="100"
  >
<send>
expInfo.gift=%1
if (exm.status==true) then
hExpMarkHandle(nil,true,"pgift")
end
</send>
</trigger>
 <trigger
 enabled="y"
 match="You add * to your group."
 send_to="14"
 sequence="100"
 >
 <send>
if minion then
minion=false
--Sound(sdir.."grouping/minion joins.ogg")
else
if not has_minion_sound then
--Sound(sdir.."grouping/you add someone.ogg")
else
has_minion_sound = nil
end
if (grouped==0) then
if gs("automark") == 2 then
  if exm.status == nil and leader == settings.me.status then -- if user isn't already marking and user is the group leader
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
elseif gs("automark") == 3 then
  if exm.status == nil and leader ~= settings.me.status then -- if user isn't already marking
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
elseif gs("automark") == 4 then
  if exm.status == nil then -- if user isn't already marking
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
end -- automark is enabled
end
end
</send>
 </trigger>
<trigger
enabled="y"
match="^You weep as you think of the (\d+) experience that you lost.$"
regexp="y"
 omit_from_output="n"
 send_to="14"
 sequence="100"
>
<send>
expInfo.death=tonumber("%1")
if (exm.status==true) then
hExpMarkHandle(nil,true,"death")
end
</send>
</trigger>
 <trigger
 enabled="y"
 match="You are now a group member."
 send_to="14"
 sequence="100"
 >
 <send>--Sound(sdir.."grouping/you join.ogg")
-- help note disabled to discourage general use
-- Note("Note: To learn to use the group bots, use the '!help' command.")
if gs("automark") == 2 then
  if exm.status == nil and leader == settings.me.status then -- if user isn't already marking and user is the group leader
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
elseif gs("automark") == 3 then
  if exm.status == nil and leader ~= settings.me.status then -- if user isn't already marking
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
elseif gs("automark") == 4 then
  if exm.status == nil then -- if user isn't already marking
    Note("Starting automatic group exp mark.")
    Execute("exm")
  end
end -- automark is enabled
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You earn * experience points*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You earn "..ntrunk("%1").." experience.")
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You gain * experience points*"
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You earn "..ntrunk("%1").." experience.")
</send>
 </trigger>

 <trigger
 enabled="y"
 match="You learn very little from this battle.  You receive * experience."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You learn very little from this battle.  You receive "..ntrunk("%1").." experience.")
death_exp(%1)
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You receive * experience."
 omit_from_output="y"
 send_to="14"
 sequence="100"
 >
 <send>
Note("You receive "..ntrunk("%1").." experience.")
death_exp(%1)
</send>
 </trigger>

-----------------------------------------------------------------------------------
-- COLORS SECTION
-----------------------------------------------------------------------------------

 <trigger
 enabled="y"
 match="kxwt_edeath *"
 omit_from_output="y"
 omit_from_log="y"
 send_to="14"
 sequence="100"
 >
<send>ColourNote("red", "", "GROUP: %1 has just been KILLED!")</send>
</trigger>

  <trigger
   enabled="y"
   match="You drive a stake through *'s shadow, pinning it in place!"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>ColourNote("blueviolet", "", "You drive a stake through %1 shadow, pinning it in place!")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Your sickening touch spreads to * as you hit it!"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>ColourNote("lime", "", "Your sickening touch spreads to %1 as you hit it!")</send>
  </trigger>
  <trigger
   enabled="y"
   match="* concentrates, and conjures a huge wall of ice."
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>ColourNote("cyan", "", "%1 concentrates, and conjures a huge wall of ice.")</send>
  </trigger>
  <trigger
   enabled="y"
   match="The white aura around your body fades."
   omit_from_output="n"
   send_to="12"
   sequence="100"
  >
  <send>ColourNote("yellow", "", "WARNING: SANCTUARY DOWN")</send>
  </trigger>
  <trigger
   enabled="y"
   match="Double mob experience is now enabled!"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>
ColourNote("lime", "black", "---------------------------")
ColourNote("lime", "black", "| DOUBLE EXP MODE ENABLED |")
ColourNote("lime", "black", "---------------------------")
</send>
  </trigger>
  <trigger
   enabled="y"
   match="Double experience caps for mob kills are now enabled!"
   omit_from_output="y"
   send_to="12"
   sequence="100"
  >
  <send>
ColourNote("lime", "black", "---------------------------")
ColourNote("lime", "black", "| DOUBLE CAP MODE ENABLED |")
ColourNote("lime", "black", "---------------------------")
</send>
  </trigger>




-----------------------------------------------------------------------------------
-- SOUNDS SECTION 
-----------------------------------------------------------------------------------
 <trigger
 enabled="y"
 match="* tells you, '*'"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/tell.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* replies to you, '*'"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/tell.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You buy * for * gold coins."
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/Purchase.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You get * from the corpse of *"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/Item.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="^kxwt_walkdir (\d+)"
 regexp="y"
 omit_from_output="y"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/Walk.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Your leaping attack *** DEMOLISHES *** *!"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/demolishleap.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You close *."
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/door.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You open *."
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/door.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You cleave through your enemies!"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/cleave.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="* (unique)"
regexp="n"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/random.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 match="You begin casting Nar's famous spell..."
regexp="n"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/rottingsphere.wav") 
</send>
 </trigger>
<trigger
 enabled="y"
 match="* throws * head back and cackles with insane glee."
regexp="n"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/cackle.wav") 
</send>
 </trigger>
<trigger
 enabled="y"
 match="You throw your head back and cackle with insane glee."
regexp="n"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/cackle.wav") 
</send>
 </trigger>
<trigger
 enabled="y"
 match="The white aura around your body fades."
regexp="n"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/sancfall.wav") 
</send>
 </trigger>
 <trigger
 enabled="y"
 group="generalSounds"
 match="* is DEAD!"
 omit_from_output="n"
 sequence="100"
 send_to="14"
 >
<send>
Sound ("sounds/death.mp3")
</send>
 </trigger>

------------------------------------------------------------------------------------
-- MUSIC SECTION
------------------------------------------------------------------------------------
 <trigger
 enabled="y"
 match="Soth's Splendiferous Storefront - http://alteraeon.com:8080/shops/45301"
 regexp="n"
 omit_from_output="n"
 sequence="100"
 send_to="14"
 >
<send>if musicPlaying == false then
				musicPlaying = true
				Sound("loop=sounds/Sothstore.mp3")
  		end -- if musicPlaying
</send>
 </trigger>
 <trigger
 enabled="y"
 match="Succumbing to your vivid and haunted thoughts of demons, you find"
 regexp="n"
 omit_from_output="n"
 sequence="100"
 send_to="14"
 >
<send>
if musicPlaying == false then
				musicPlaying = true
				Sound("loop=sounds/entrancetohell.mp3")
  		end -- if musicPlaying
</send>
 </trigger>
 <trigger
 enabled="y"
 match="kxwt_area 5400 Underwater ruins, watery passages"
 regexp="n"
 omit_from_output="y"
 sequence="1"
 send_to="14"
 >
  <send>if musicPlaying == false then
			musicPlaying = true
			Sound("loop=sounds/uw_ruins.mp3")
		end -- if musicPlaying</send></trigger>
</triggers>
------------------------------------------------------------------------------------
-- ALIASES SECTION 
------------------------------------------------------------------------------------

   <aliases>
   <alias
   match="kxwt_area --printareanumber"
	send_to="12"
   enabled="y"
   sequence="100"
  >
<send>Note(areanumber)</send></alias>
   <alias
   match="mute"
	send_to="12"
   enabled="y"
   sequence="100"
  >
<send>Sound("stop=all")
musicPlaying = false
   ColourNote ("yellow", "", "Current Music Stopped.")
</send>
</alias>

  <alias
   match="dbn"
send_to="12"
   enabled="y"
   sequence="100"
  >
  <send>if debugging==1 then
			debugging=0
			Note("debugging disabled")
		else
			Note("debugging enabled")
			debugging=1
		end</send></alias>
  <alias
   match="dbn"
	send_to="12"
   enabled="y"
   sequence="100"
  >
  <send>if debugging==1 then
			debugging=0
			Note("debugging disabled")
		else
			Note("debugging enabled")
			debugging=1
		end</send></alias>
  <alias
   match="random * *"
	send_to="12"
   enabled="y"
   sequence="100"
  >
  <send>print(random(%1,%2))</send></alias>

 <alias
 match="lag"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>
lagbrag = nil
Send("ping")
</send>
 </alias>
 <alias
 match="brag * lag"
 enabled="y"
 send_to="12"
 sequence="100"
 >
 <send>
lagbrag="%1"
Send("ping")
</send>
 </alias>


 <alias
 match="exm"
 enabled="y"
 group="Exp mark"
 send_to="12"
 sequence="100"
 >
 <send>
if (expInfo.exp==0 or expInfo.exp==nil) then
Note("Warning! Your xp prompt isn't available yet! Not enabling exp mark.")
--Sound(sdir.."luaaudio/error.ogg")
return -1
end-- prompt check

if not exm then exm = {} end
if not exm.events then exm.events = {} end
if not exm.events.leveled then exm.events.leveled = {} end
if not exm.events.microleveled then exm.events.microleveled = {} end
-- This may be slightly buggy
if not exm.status then
require "lua_datetime"
exm.status=true
-- Set exp marking start time for calculations later...
exm.starttime = os.time()
--set total exp gathered value
exm.markedTotal=expInfo.exp
exm.events.leveled.mageExp=0
exm.events.microleveled.mageExp=0
exm.events.leveled.clericExp=0
exm.events.microleveled.clericExp=0
exm.events.leveled.thiefExp=0
exm.events.microleveled.thiefExp=0
exm.events.leveled.warriorExp=0
exm.events.microleveled.warriorExp=0
exm.events.leveled.necromancerExp=0
exm.events.microleveled.necromancerExp=0
exm.events.leveled.druidExp=0
exm.events.microleveled.druidExp=0
exm.events.practExp=0
exm.events.giftExp=0
exm.events.deathExp=0

Note("Exp mark enabled.")
Note("To disable it, type exm off")
Note("To get a detailed report, type exm report.")
--Sound(sdir.."luaaudio/on.ogg")
elseif exm.status then -- exp mark is already enabled, report
hExpMarkHandle()
end
</send>
 </alias>
<alias
match="^avexm$"
regexp="y"
 enabled="y"
 group="Exp mark"
send_to="12"
 sequence="100"
 >
<send>
hExpMarkHandle(nil,nil,nil,nil,nil,true)
</send>
</alias>
<alias
match="^exm (?:rep|repo|repor|report)$"
regexp="y"
 enabled="y"
 group="Exp mark"
send_to="12"
 sequence="100"
 >
<send>
if not exm.status then
Note("Exp Marking is currently disabled. Nothing to report.")
else
hExpMarkHandle(nil,false,nil,true)
end
</send>
</alias>

 <alias
 match="exm off"
 enabled="y"
 group="Exp mark" send_to="12"
 sequence="100"
 >
 <send>if not exm then exm = {} end
if not exm.status then
Note("You're not currently exp marking. Type exm to start.")
else
hExpMarkHandle()
Note("Exp marking disabled.")
--Sound(sdir.."luaaudio/off.ogg")
exm = { }
end</send>
 </alias>
  <alias
   match="^bra(|g) (\w*) (mark|exm|marked|expgained|explost)"
   enabled="y"
   group="Exp mark"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>
if exm.status then -- exp marking enabled
hExpMarkHandle("%2")
else
Note("You're not currently exp marking (try exm), nothing to brag about.")
end
</send>
  </alias>

  <alias
   match="^exm settime (\d*) (\d*) (\d*)$"
   enabled="y"
   group="Exp mark"
   regexp="y"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
  <send>-- test alias to set the time for exp mark
-- 1st arg should be the number of hours to add to the exp mark clock
-- 2nd arg should be the number of minutes to add to the exp mark clock
-- 3rd arg should be the number of seconds to add to the exp mark clock
if not exm.status then
Note("Error, exp marking not enabled... starting...")
Execute("exm")
Note("Continueing...")
Execute("exm settime %1 %2 %3")
else -- exp mark is enabled
if tonumber("%1") >= 1 then
local hourstosub = tonumber("%1")*3600 -- multiply the number of hours we're supposed to add to the clock (which really means subtract from the starting time) by the number of seconds in an hour
exm.starttime = exm.starttime-hourstosub
end
if tonumber("%2") >=1 then
local minstosub = tonumber("%2")*60
exm.starttime = exm.starttime-minstosub
end
if tonumber("%3") >=1 then
local secstosub = tonumber("%3")
exm.starttime=exm.starttime-secstosub
end
Note("Ok, %1 hours, %2 minutes, and %3 seconds added to the exp mark clock.")
end</send>
  </alias>
<alias
   match="ttsexp"
   enabled="y"
   regexp="n"
   send_to="12"
   ignore_case="y"
   sequence="100"
  >
    <send>
if expInfo.exp == nil or
expInfo.tnl.exp==nil or
expInfo.tnl.class==nil or
expInfo.tnl.class=="none" then 
  Note("You haven't received any experience since loading the client, so no information is available yet.")
return -1
end
--check for practice global option enabled.
if("praccing")==true) then
  if exm.status == true then
    Execute("tts_interrupt "..ntrunk(expInfo.exp).." xp / "..ntrunk(expInfo.practices.requirement).." xp to train a practice ("..math.floor((expInfo.exp/expInfo.practices.requirement)*100).."%), marking enabled.") 
  else
    Execute("tts_interrupt "..ntrunk(expInfo.exp).." xp / "..ntrunk(expInfo.practices.requirement).." xp to train a practice ("..math.floor((expInfo.exp/expInfo.practices.requirement)*100).."%)") 
  end
else
  if exm.status == true then
    Execute("tts_interrupt "..ntrunk(expInfo.exp).." xp / "..ntrunk(expInfo.tnl.exp).." xp to level "..expInfo.tnl.class.." ("..math.floor((expInfo.exp/expInfo.tnl.exp)*100).."%), marking enabled.") 
  else
    Execute("tts_interrupt "..ntrunk(expInfo.exp).." xp / "..ntrunk(expInfo.tnl.exp).." xp to level "..expInfo.tnl.class.." ("..math.floor((expInfo.exp/expInfo.tnl.exp)*100).."%)") 
  end
end
</send>
  </alias>


  </aliases>
  


<!--  Script  -->

<script>
<![CDATA[
exp=0
expInfo = {}
expInfo.levelTBL = {}
expInfo.lastDeath = 0
expInfo.exp = 0
expInfo.prevexp = 0
expInfo.practices={}
expInfo.practices.requirement = 0
expInfo.practices.count=nil
expInfo.tnl = {}
exm = {}
exm.events = {}
exm.events.leveled = {}
exm.events.microleveled = {}
exptnl=0
  classtnl="none"
death_exp=0

  prevlength=0
  prevexp=0

uid=""
musicPlaying = false
function OnPluginInstall()
  -- sanity - do early init as soon as possible
  math.randomseed(os.time())
  math.random(); math.random();
  math.random(); math.random();
  startup_do_mandatory_var_init()
  startup_clear_working_vars()
  settingtables()
  uid=GetVariable("id")
  if(uid==NIL) then
    uid=GetUniqueID()
  end
end
function OnPluginSaveState ()
  SetVariable("id",uid)
end

function random(num1, num2)
	math.randomseed(os.time())
	math.random(); math.random();
	math.random(); math.random();
	randomNumber =  math.random(num1, num2)
	return randomNumber
end
	
function hGTimeHandle(n,m,w)
--The time value (wildcard 1) is in the unix style time. The only difference is that the epoch isn't 1 January 1970 00:00:00; the game time epoch is every day at midnight. Seconds are not counted either. so, for something like 13:00 (01:00 PM) their should be around 780 minutes. I wish there was a way to get the time and date by calculating that also. At least this system will never see the year 2038 problem any time soon if the total is added because it's calculating minutes, not seconds.
local total=tonumber(w[1])
if (total==0) then --reset to 00:00 (12:00 AM).
gTime.hours=0
gTime.minutes=0
end
gTime.hours=0
while (total>=60) do --find the hours
total=math.floor(total-60)

gTime.hours=math.floor(gTime.hours+1) -- add the hours to another variable every time this while loop cycles. May do for loops if they are like c style ones. I'll look into it later. We'll need this var later.
end
if (total<60 and total>0) then --get the minutes. if it's 0, that means that it has 0 minutes. 
gTime.minutes=math.floor(total)
else --it's hour:00, so put 0 minutes in.
gTime.minutes=0
end

--try to convert this 24 hour style time to something that most humans like to see:

if (gTime.hours>=12) then --Convert time 12> to PM or 0> to AM.

if (gTime.hours==12) then --leave as it is and set twelveHour to twelve or subtract 12 from the 24-hour time.
gTime.twelveHours=12
gTime.pm=true
else
gTime.twelveHours=math.floor(gTime.hours-12)
gTime.pm=true
end --leave as it is or subtract.
else

if(gTime.hours==0) then --make 12:00 AM, rather than 00:00
gTime.twelveHours=12
gTime.pm=false
end --leave at 12:00 AM
if (gTime.hours<=11 and gTime.hours) then --Make AM 12 hour time
gTime.twelveHours=gTime.hours
pm=false
end --Make AM twelve-hour time.
end --convert time 12> to PM
--call a function to run code when this function is called.
gameTime_external_code()
return 0
end --function

function k_level(n,m,w)
EnableGroup("show",1)
local micro=w[1]
local leveledStringHolder=w[3]

--Sound(sdir .. "level/"..leveledStringHolder..".ogg")
if exm.status == true then
if (micro=="microlevel") then
hExpMarkHandle(nil,true,leveledStringHolder,false,true)
else
hExpMarkHandle(nil,true,leveledStringHolder,false,false)
end
end
PSend("show cost | prefix tnl")
PSend("level|prefix lvltbl:")
end --function

function hLvltbl(n,m,w)
if not expInfo.levelTBL[w[1]] then expInfo.levelTBL[w[1]] = {} end
if (w[1]=="Mage") then
expInfo.levelTBL.Mage.requirement=w[5]
elseif (w[1]=="Cleric") then
expInfo.levelTBL.Cleric.requirement=w[5]
elseif (w[1]=="Thief") then
expInfo.levelTBL.Thief.requirement=w[5]
elseif (w[1]=="Warrior") then
expInfo.levelTBL.Warrior.requirement=w[5]
elseif (w[1]=="Necromancer") then
expInfo.levelTBL.Necromancer.requirement=w[5]
elseif (w[1]=="Druid") then
expInfo.levelTBL.Druid.requirement=w[5]
end --adding required xp to level
--port exp cap:
if (tonumber(w[9])) then
k_cap=tonumber(w[9])
end
end --function

function hPracticeTbl(n,m,w)
--check to see if a practice count is defined:
if (expInfo.practices.count==nil) then
expInfo.practices.count=tonumber(w[1])
return 0
end
--now with the new value:
if (expInfo.practices.count>=0) then
--Pass the new practice count to verify.
practiceGain(tonumber(w[1]))
return 0
end

end

function practiceGain(newCount)
--check for it to be a real practice:

if(is_practice(expInfo.practices.count,newCount)==-1) then
return -1
end
expInfo.practices.count=expInfo.practices.newCount
classtnl="practice"
exptnl=praccost
Execute("tnp")
if (exm.status==true) then
hExpMarkHandle(nil,true,"pract")
  PSend("show cost practice|prefix praccost:")
end
end

function is_practice(oldCount,newCount)
if (oldCount==(newCount-1)) then
return 0
else
return -1
end
end


function hExpMarkHandle(bragTo,add,event,report,micro,shortReport,hourRefresh,quiet)
--check to see if the variables are set.
if not exm.status then
if not quiet then Note("You are not marking.") end
return -1
end
--if nothing is going to be tract.
if not add then
--set time variables
  local marksecs =os.difftime(os.time(), exm.starttime) -- calculate seconds since we started marking
  local totalsecs=marksecs--minimize rounding error by using the raw seconds.
 local markmins, marksecs = sec2min(marksecs)

 local markhours=math.floor(markmins/60) -- calculate how many hours total
--add the tracked lost xp:
local added=math.floor(exm.events.leveled.mageExp+exm.events.microleveled.mageExp+exm.events.leveled.clericExp+exm.events.microleveled.clericExp+exm.events.leveled.thiefExp+exm.events.microleveled.thiefExp+exm.events.leveled.warriorExp+exm.events.microleveled.warriorExp+exm.events.leveled.necromancerExp+exm.events.microleveled.necromancerExp+exm.events.leveled.druidExp+exm.events.microleveled.druidExp+exm.events.practExp+exm.events.deathExp+exm.events.giftExp)
--get a final sum of the calculated exp.
local total=math.floor(expInfo.exp-exm.markedTotal+added)
--The user requesting a detailed report
if (report==true) then

Note("Experience marked detailed report since started:")
Note ("You have gained a total of "..ntrunk(total).." experience this session.")
	if (exm.events.microleveled.mage) then Note("You have microleveled Mage "..ntrunk(exm.events.microleveled.mage).." times.") end
if (exm.events.leveled.mage) then Note("You have leveled Mage "..exm.events.leveled.mage.." times.") end
if (exm.events.microleveled.mage or exm.events.leveled.mage) then Note("You have spent a total of "..ntrunk(exm.events.leveled.mageExp+exm.events.microleveled.mageExp).." experience microleveling and/or leveling Mage this session.") end

if (exm.events.microleveled.cleric) then Note("You have microleveled Cleric "..ntrunk(exm.events.microleveled.cleric).." times.") end
if (exm.events.leveled.cleric) then Note("You have leveled Cleric "..exm.events.leveled.cleric.." times.") end
if (exm.events.microleveled.cleric or exm.events.leveled.cleric) then Note("You have spent a total of "..ntrunk(exm.events.leveled.clericExp+exm.events.microleveled.clericExp).." experience leveling and/or microleveling Cleric this session.") end

if (exm.events.leveled.thief) then Note("You have leveled Thief "..exm.events.leveled.thief.." times.") end
if (exm.events.microleveled.thief) then Note("You have microleveled Thief "..exm.events.microleveled.thief.." times.") end
if (exm.events.microleveled.thief or exm.events.leveled.thief) then Note("You have spent a total of "..ntrunk(exm.events.leveled.thiefExp+exm.events.microleveled.thiefExp).." experience leveling and/or microleveling Thief this session.") end

if (exm.events.leveled.warrior) then Note("You have leveled Warrior "..exm.events.leveled.warrior.." Times.") end
if (exm.events.microleveled.warrior) then Note("You have microleveled Warrior "..exm.events.microleveled.warrior.." times.") end
if (exm.events.microleveled.warrior or exm.events.leveled.warrior) then Note("You have spent a total of "..ntrunk(exm.events.leveled.warriorExp+exm.events.microleveled.warriorExp).." experience leveling and/or microleveling Warrior this session.") end

if (exm.events.leveled.necromancer) then Note("You have leveled Necromancer "..exm.events.leveled.necromancer.." times.") end
if (exm.events.microleveled.necromancer) then Note("You have microleveled Necromancer "..exm.events.microleveled.necromancer.." times.") end
if (exm.events.microleveled.necromancer or exm.events.leveled.necromancer) then Note("You have spent a total of "..ntrunk(exm.events.leveled.necromancerExp+exm.events.microleveled.necromancerExp).." experience leveling and/or microleveling Necromancer this session.") end

if (exm.events.leveled.druid) then Note("You have leveled Druid "..exm.events.leveled.druid.." times.") end
if (exm.events.microleveled.druid) then Note("You have microleveled Druid "..exm.events.microleveled.druid.." times.") end
if (exm.events.microleveled.druid or exm.events.leveled.druid) then Note("You have spent a total of "..ntrunk(exm.events.leveled.druidExp+exm.events.microleveled.druidExp).." experience leveling and/or microleveling Druid this session.") end
if (exm.events.pract) then Note("You have trained "..exm.events.pract.." practices.") end
if (exm.events.gift) then Note("You have gifted "..exm.events.gift.." newbies.") end
if (exm.events.death) then Note("You have died "..exm.events.death.." times this session, and you have lost a total of "..ntrunk(exm.events.deathExp).." experience do to deaths.") end
if (added>1) then Note("You have used and or lost a total of "..ntrunk(added).." experience this session.") end
if (added==0) then Note("You have not lost or spent experience since you started marking.") end

return 0
end --report
--calculate avg
  local exppermin = math.floor(total/(totalsecs/60)) -- calculate exp per minute
  if markhours >=1 then -- If we've been marking for 1 hour or more
    expperhour = math.floor(total/markhours) -- calculate average exp per hour
     markmins = markmins-(markhours*60) -- convert total minutes to minutes since last hour started
  end

--lock the exp avg per hour to prevent the exp avg per hour from going up if it is before two hours
if not exm.hourExp then exm.hourExp=0 end
--only execute if the timer is at one hour

if markhours==1 then
--only copy the variables if they have 0 xp set.
if exm.hourExp == 0 then
exm.hourExp = expperhour
end
end
--return if the hourRefresh arg is passed because we don't need the rest of the code.
if hourRefresh==true then return 0 end
--Someone uses the alt+a macro
if (shortReport) then
  if markmins == 0 and markhours == 0 then -- Haven't been marking for 1 minute or 1 hour
    Note("No average yet, marking for " ..marksecs.." seconds.")
  elseif tonumber(markhours) >= 1 then -- Have been marking for more than one hour
    Note(ntrunk(exppermin) .." per minute, ".. ntrunk(expperhour) .." per hour. Marking for ".. markhours.. " hours, ".. markmins.. " minutes, and ".. marksecs .." seconds.")
  elseif tonumber(markhours) == 1 then -- Have been marking for 1 hour only
    Note(ntrunk(exppermin) .." per minute, ".. ntrunk(expperhour) .." per hour. Marking for ".. markhours.. " hours, ".. markmins.. " minutes, and ".. marksecs .." seconds.")
  else --between 1 minute and 1 hour
    Note(ntrunk(exppermin).. " per minute. Marking for ".. markmins .." minutes and ".. marksecs.. " seconds.")
  end
return 0
end
--printing avg exp, but not using the alt+a macro
  if markmins == 0 and markhours == 0 then -- Haven't been marking for 1 minute or 1 hour
    if not bragTo then
--print lost exp.
if (added>0) then
Note("You've been marking for " ..marksecs.." seconds, gained " ..ntrunk(total).. " experience, but you haven't been marking long enough to determine your exp per minute rate. You have used and or lost a total of "..ntrunk(added).." experience do to events such as leveling and death.")
else
--do not print the lost exp sentence if the player hasn't lost xp
      Note("You've been marking for " ..marksecs.." seconds, gained " ..ntrunk(total).. " experience, but you haven't been marking long enough to determine your exp per minute rate.")
end
    else
--if someone wants to brag
if (added>0) then
--same pattern as above
      Send(bragTo.." I have been marking for " ..marksecs.." seconds, gained " ..num2fstr(total).. " experience, but I haven't been marking long enough to determine my exp per minute rate. I have spent and or lost a total of "..num2fstr(added).." experience do to events such as leveling and death.") --I plan on adding a more detailed report only when the user doesn't brag. Imo we don't need that much spam when we brag. 
else
Send(bragTo.." I have been marking for " ..marksecs.." seconds, gained " ..num2fstr(total).. " experience, but I haven't been marking long enough to determine my exp per minute rate.")
end
    end -- Haven't been marking for 1 minute or 1 hour
elseif tonumber(markhours) == 1 then --only been marking for one hour
    if not bragTo then 
if (added>0) then
      Note("You have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute, and " ..ntrunk(exm.hourExp).." per hour. You have spent and or lost a total of "..ntrunk(added).." experience do to events such as leveling and death.")
else
      Note("You have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute, and " ..ntrunk(exm.hourExp).." per hour.")
end
    else
if (added>0) then
      Send(bragTo.." I have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute, and " ..num2fstr(exm.hourExp).." per hour. I have spent and or lost a total of "..num2fstr(added).." experience do to events such as leveling and death.")
else
      Send(bragTo.." I have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute, and " ..num2fstr(exm.hourExp).." per hour.")
end
    end -- marking for one hour

  elseif tonumber(markhours) > 1 then -- Have been marking for more than one hour
    if not bragTo then 
if (added>0) then
      Note("You have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute, and " ..ntrunk(expperhour).." per hour. You have spent and or lost a total of "..ntrunk(added).." experience do to events such as leveling and death.")
else
      Note("You have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute, and " ..ntrunk(expperhour).." per hour.")
end
    else
if (added>0) then
      Send(bragTo.." I have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute, and " ..num2fstr(expperhour).." per hour. I have spent and or lost a total of "..num2fstr(added).." experience do to events such as leveling and death.")
else
      Send(bragTo.." I have been marking for " ..markhours.. "hours, " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute, and " ..num2fstr(expperhour).." per hour.")
end
    end -- have been bragging for an hour or more
  else --between 1 minute and 1 hour
    if not bragTo then 
if (added>0) then
      Note("You have been marking for " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute. You have spent and or lost a total of "..ntrunk(added).." experience do to events such as leveling and death.")
else
      Note("You have been marking for " ..markmins.." minutes and "..marksecs.." seconds, gained "..ntrunk(total).." experience, for an average rate of " ..ntrunk(exppermin).. " exp per minute.")
end
    else
if (added>0) then
      Send(bragTo.." I have been marking for " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute. I have spent and or lost a total of "..num2fstr(added).." experience do to events such as leveling and death.")
else
      Send(bragTo.." I have been marking for " ..markmins.." minutes and "..marksecs.." seconds, gained "..num2fstr(total).." experience, for an average rate of " ..num2fstr(exppermin).. " exp per minute.")
end
    end
  end -- main if
  markhours = nil
  markmins = nil
  exppermin = nil
  expperhour = nil
else
--track lost xp by importing the numbers into variables
--add mage levels
if (event=="mage" and micro==false) then
if not exm.events.leveled.mageExp then exm.events.leveled.mageExp=0 end
exm.events.leveled.mageExp=math.floor(expInfo.levelTBL.Mage.requirement+exm.events.leveled.mageExp)
if not exm.events.leveled.mage then exm.events.leveled.mage=0 end
exm.events.leveled.mage=math.floor(exm.events.leveled.mage+1)

elseif (event=="mage" and micro==true) then
if not exm.events.microleveled.mageExp then exm.events.microleveled.mageExp=0 end
exm.events.microleveled.mageExp=math.floor(expInfo.levelTBL.Mage.requirement+exm.events.microleveled.mageExp)
if not exm.events.microleveled.mage then exm.events.microleveled.mage=0 end
exm.events.microleveled.mage=math.floor(exm.events.microleveled.mage+1)

--add cleric levels
elseif (event=="cleric" and micro==false) then
if not exm.events.leveled.clericExp then exm.events.leveled.clericExp=0 end
exm.events.leveled.clericExp=math.floor(expInfo.levelTBL.Cleric.requirement+exm.events.leveled.clericExp)
if not exm.events.leveled.cleric then exm.events.leveled.cleric=0 end
exm.events.leveled.cleric=math.floor(exm.events.leveled.cleric+1)

elseif (event=="cleric" and micro==true) then
if not exm.events.microleveled.clericExp then exm.events.microleveled.clericExp=0 end
exm.events.microleveled.clericExp=math.floor(expInfo.levelTBL.Cleric.requirement+exm.events.microleveled.clericExp)
if not exm.events.microleveled.cleric then exm.events.microleveled.cleric=0 end
exm.events.microleveled.cleric=math.floor(exm.events.microleveled.cleric+1)

--add thief levels
elseif (event=="thief" and micro==false) then
if not exm.events.leveled.thiefExp then exm.events.leveled.thiefExp=0 end
exm.events.leveled.thiefExp=math.floor(expInfo.levelTBL.Thief.requirement+exm.events.leveled.thiefExp)
if not exm.events.leveled.thief then exm.events.leveled.thief=0 end
exm.events.leveled.thief=math.floor(exm.events.leveled.thief+1)

elseif (event=="thief" and micro==true) then
if not exm.events.microleveled.thiefExp then exm.events.microleveled.thiefExp=0 end
exm.events.microleveled.thiefExp=math.floor(expInfo.levelTBL.Thief.requirement+exm.events.microleveled.thiefExp)
if not exm.events.microleveled.thief then exm.events.microleveled.thief=0 end
exm.events.microleveled.thief=math.floor(exm.events.microleveled.thief+1)

--add warrior levels
elseif (event=="warrior" and micro==false) then
if not exm.events.leveled.warriorExp then exm.events.leveled.warriorExp=0 end
exm.events.leveled.warriorExp=math.floor(expInfo.levelTBL.Warrior.requirement+exm.events.leveled.warriorExp)
if not exm.events.leveled.warrior then exm.events.leveled.warrior=0 end
exm.events.leveled.warrior=math.floor(exm.events.leveled.warrior+1)

elseif (event=="warrior" and micro==true) then
if not exm.events.microleveled.warriorExp then exm.events.microleveled.warriorExp=0 end
exm.events.microleveled.warriorExp=math.floor(expInfo.levelTBL.Warrior.requirement+exm.events.microleveled.warriorExp)
if not exm.events.microleveled.warrior then exm.events.microleveled.warrior=0 end
exm.events.microleveled.warrior=math.floor(exm.events.microleveled.warrior+1)

--add necromancer levels
elseif (event=="necromancer" and micro==false) then
if not exm.events.leveled.necromancerExp then exm.events.leveled.necromancerExp=0 end
exm.events.leveled.necromancerExp=math.floor(expInfo.levelTBL.Necromancer.requirement+exm.events.leveled.necromancerExp)
if not exm.events.leveled.necromancer then exm.events.leveled.necromancer=0 end
exm.events.leveled.necromancer=math.floor(exm.events.leveled.necromancer+1)

elseif (event=="necromancer" and micro==true) then
if not exm.events.microleveled.necromancerExp then exm.events.microleveled.necromancerExp=0 end
exm.events.microleveled.necromancerExp=math.floor(expInfo.levelTBL.Necromancer.requirement+exm.events.microleveled.necromancerExp)
if not exm.events.microleveled.necromancer then exm.events.microleveled.necromancer=0 end
exm.events.microleveled.necromancer=math.floor(exm.events.microleveled.necromancer+1)

--add druid levels
elseif (event=="druid" and micro==false) then
if not exm.events.leveled.druidExp then exm.events.leveled.druidExp=0 end
exm.events.leveled.druidExp=math.floor(expInfo.levelTBL.Druid.requirement+exm.events.leveled.druidExp)
if not exm.events.leveled.druid then exm.events.leveled.druid=0 end
exm.events.leveled.druid=math.floor(exm.events.leveled.druid+1)

elseif (event=="druid" and micro==true) then
if not exm.events.microleveled.druidExp then exm.events.microleveled.druidExp=0 end
exm.events.microleveled.druidExp=math.floor(expInfo.levelTBL.Druid.requirement+exm.events.microleveled.druidExp)
if not exm.events.microleveled.druid then exm.events.microleveled.druid=0 end
exm.events.microleveled.druid=math.floor(exm.events.microleveled.druid+1)

--track practices
elseif (event=="pract") then
if not exm.events.practExp then exm.events.practExp=0 end
exm.events.practExp=math.floor(expInfo.practices.requirement+exm.events.practExp)
if not exm.events.pract then exm.events.pract=0 end
exm.events.pract=math.floor(exm.events.pract+1)
--track lost xp when you die
elseif (event=="death") then
if not exm.events.deathExp then exm.events.deathExp=0 end
exm.events.deathExp=math.floor(expInfo.death+exm.events.deathExp)
if not exm.events.death then exm.events.death=0 end
exm.events.death=math.floor(exm.events.death+1)
--track lost xp while giving players newbie gifts
elseif (event=="pgift") then
if not exm.events.giftExp then exm.events.giftExp=0 end
exm.events.giftExp=math.floor(expInfo.gift+exm.events.giftExp)
if not exm.events.gift then exm.events.gift=0 end
exm.events.gift=math.floor(exm.events.gift+1)
end 

end --adding
end--function
function k_exp(n,l,w)
if (not w) then
  exp = 0
else
  exp=tonumber(w[1])
  expInfo.exp=tonumber(w[1])
end
if areaxp==0 then areaxp=exp end
if (exp<prevexp) or (exp>prevexp) then
if (tonumber(exptnl)==0 and ("praccing")==true) then
exptnl=praccost
classtnl="practice"
end
if (("bars")~=3) then
if (exp~=0) and (exptnl~=0) then
if not (math.floor(exp/exptnl*100)==prevxpc) then
--PanSnd(exp,exptnl,sdir.."pm/xp.ogg")
end
end
prevxpc=math.floor(exp/exptnl*100)
if (exp / exptnl * 100 > 100) then
if not (classtnl=="none") then
if (("praccing") == true) then
r="yes"
if (r=="yes") then
play("notifications/millxp",0)
PSend("train prac")
else
Execute("config praccing")
end
else
if classtnl == "practice" then
Note("You can now train a practice!")
else
Note("You can now level "..classtnl.."!")
end
play("notifications/millxp",0)
end
classtnl="none"
end
end
else
if not (classtnl=="none") then
if not (math.floor(exp/exptnl*100)==prevxpc) then
Note("xp "..math.floor(exp/exptnl*100).." percent")
end
prevxpc=math.floor(exp/exptnl*100)
if (exp / exptnl * 100 > 100) then
if (("praccing") == true) then
r="yes"
if (r=="yes") then
play("notifications/millxp",0)
PSend("train prac")
else
Execute("config praccing")

end

else
Note("You can now level "..classtnl.." to "..levtnl.."!")
play("notifications/millxp",0)
end
classtnl="none"
end
end
end --exp
prevexp=exp
end --prevexp
end
function ntrunk(n)
n=tostring(n)
if not (gs("ntrunk") == true) then
return n
end
if (#n< 5) then
return n
elseif (#n == 5) then
return string.sub(n, 1, 2).."k"
elseif (#n == 6) then
return string.sub(n, 1, 3).."k"
elseif (#n == 7) then
if (string.sub(n, 2, 2) == "0") then
return string.sub(n, 1,1).." mill"
else
return string.sub(n, 1, 1).."."..string.sub(n, 2,2).."mill"
end
elseif (#n == 8) then
if (string.sub(n, 3, 3) == "0") then
return string.sub(n, 1,2).." mill"
else
return string.sub(n, 1, 2).."."..string.sub(n, 3,3).."mill"
end
elseif (#n == 9) then
if (string.sub(n, 4, 4) == "0") then
return string.sub(n, 1,3).." mill"
else
return string.sub(n, 1, 3).."."..string.sub(n, 4,4).."mill"
end
elseif (#n == 10) then
if (string.sub(n, 2, 2) == "0") then
return string.sub(n, 1,1).." bill"
else
return string.sub(n, 1, 1).."."..string.sub(n, 2,2).."bill"
end
elseif (#n == 11) then
if (string.sub(n, 3, 3) == "0") then
return string.sub(n, 1,2).." bill"
else
return string.sub(n, 1, 2).."."..string.sub(n, 3,3).."bill"
end
elseif (#n == 12) then
if (string.sub(n, 4, 4) == "0") then
return string.sub(n, 1,3).." bill"
else
return string.sub(n, 1, 3).."."..string.sub(n, 4,4).."bill"
end
end --main if
end --func
-------------------------------------------------------------
-- get and set functions for global config
-------------------------------------------------------------

function gs(v)
  if settings[v]==nil then
    Note("WARNING - referencing uninitialized config variable '"..v.."'.")
    settings[v]={}
  end
  return settings[v].status
end

function ss(v,val)
  if settings[v]==nil then
    -- Note("DEBUG - creating new config variable '"..v.."'.")
    settings[v]={}
  end
  if (settings[v].status ~= val) then
    -- only save if necessary
    settings[v].status=val
    SaveState()
  end
  check_visible(v)
end

-------------------------------------------------------------
-- various functions for default configuration types
-------------------------------------------------------------

function sanity_check_bool_config_setting(v, arg, visible)
  if not settings[v] then
    settings[v] = {}
  end
  if settings[v].status ~= true and settings[v].status ~= false then
    settings[v].status = arg
  end
  if visible==nil then visible=true end
  if settings[v].visible==nil then
    settings[v].visible=visible
  end
end

function sanity_check_int_config_setting(v, arg, visible)
  if not settings[v] then
    settings[v] = {}
  end
  if visible==nil then visible=true end
  if settings[v].visible==nil then
    settings[v].visible=visible
  end
  -- check for nil loaded setting
  if settings[v].status == nil then
    settings[v].status = arg
    return
  end
  -- convert loaded bool settings to integer
  if settings[v].status == true or settings[v].status == false then
    settings[v].status = arg
    return
  end
end

function configure_minimal_settings() 
  Note("Using minimal configuration. Most sounds and music have been disabled, as well as all filters.")
  disable_all_filters()

  settings.ambience.status=false
  settings.antigroundstringspam.status=false
  settings.areamusic.status=false
  settings.showsize.status=true
  settings.unexplored.status=false
  settings.autoopen.status=false
  settings.automark.status = 1
  settings.automove.status=false
  settings.autopick.status=true
  settings.autoregen.status=false

  settings.autosleep.status=false
  settings.autostat.status=true
  settings.autotime.status        = 1
  settings.bars.status=3             -- give enemy hp in text
  settings.battlemusic.status=false

  settings.brewlog.status=true
  settings.comlog.status=false
  settings.comlogchans.status=false
  settings.comlogtells.status=false
  settings.comlogclan.status=false
  settings.comlogfriends.status=false
  settings.chans.status=1
  settings.chist.status=false

  settings.clannotify.status=false
  settings.clanfame.status=false
  settings.clanactive.status=false
  settings.clansize.status=false
  settings.clanpk.status=false

  settings.clanwar.status=false
  settings.dcomps.status=1
  settings.randomsaction.status=2
  settings.deathaction.status=true
  settings.deathactionbloodsac.status=1
  settings.deathactionharvestteeth.status=1
  settings.deathactionconsume.status=1
  settings.deathactionspellcomp.status=1
  settings.deathactionsalvage.status=1
  settings.donfish.status=false
  settings.dteeth.status=false

  settings.enterinterrupt.status=false
  settings.elderBuffer.status=false
  settings.exits.status=1
  settings.expall.status=true
  settings.gdamage.status=false

  settings.globalareamusic.status=false
  settings.grecast.status=false
settings.groupdice.status=1
  settings.grunts.status=false
    settings.ifollow.status=false
  settings.imove.status=false

  settings.items.status=3
  settings.logarena.status=true
  settings.logpk.status=false
  settings.musictype.status=1
  settings.ntrunk.status=false

  settings.playquotes.status=false
  settings.praccing.status=false
  settings.randomambience.status=false
  settings.randoms.status=2

  settings.rebootsounds.status=1
  settings.recast.status=false
  settings.recastsleeping.status=true
  settings.reclay.status=false
  settings.minionmonitor.status=true
  settings.regen.status=3
  settings.runeinfo.status = 1
  settings.sacsplit.status=false

  settings.scheme.status=2
  settings.shortall.status=false
  settings.shortid.status=1
  settings.showtips.status=false

  settings.soulsteal.status=false
  settings.soulaction.status=false
  settings.sellstruggle.status=false
  settings.speedwalk.status=false
  settings.spellsfall.status=2
  settings.sunsounds.status = false

  settings.swarn.status=false
  settings.ticksounds.status=false

  settings.tts.status=true
  settings.warn.status=false
end

function configure_default_settings()
  Note("OK, configured for default settings, default filters.")
  set_default_filters()

  -- NOTE - these settings should match the sanity check config settings below
  settings.ambience.status        = true
  settings.antigroundstringspam.status=false
settings.showsize.status=true
  settings.unexplored.status=false
  settings.areamusic.status       = false   -- this is too busy with ambience also enabled
  settings.autoopen.status      = false

  settings.automark.status = 1
  settings.automove.status        = true
  settings.autopick.status        = true
  settings.autoregen.status       = false

  settings.autosleep.status       = false
  settings.autostat.status        = true
  settings.autotime.status        = 3
  settings.bars.status            = 2             -- give enemy hp via pitch change
  settings.battlemusic.status     = true

  settings.brewlog.status         = true
  settings.comlog.status=false
  settings.comlogchans.status=false
  settings.comlogtells.status=false
  settings.comlogclan.status=false
  settings.comlogfriends.status=false
  settings.chans.status           = 1
  settings.chist.status           = false

  settings.clannotify.status=false
  settings.clanfame.status=false
  settings.clanactive.status=false
  settings.clansize.status=false
  settings.clanpk.status=false

  settings.clanwar.status         = true
  settings.dcomps.status          = 1
  settings.randomsaction.status          = 2
  settings.deathaction.status=false
  settings.deathactionbloodsac.status=1
  settings.deathactionharvestteeth.status=1
  settings.deathactionconsume.status=1
  settings.deathactionspellcomp.status=1
  settings.deathactionsalvage.status=1
  settings.donfish.status         = false
  settings.dteeth.status          = false

  settings.enterinterrupt.status  = false
  settings.elderBuffer.status=false
  settings.exits.status           = 1
  settings.expall.status          = true
  settings.gdamage.status         = true

  settings.globalareamusic.status = true
  settings.grecast.status         = false
settings.groupdice.status=2
  settings.grunts.status         = true
  settings.ifollow.status         = false
  settings.imove.status           = true

  settings.items.status           = 3
  settings.logarena.status=true
  settings.logpk.status           = false
  settings.musictype.status       = 1
  settings.ntrunk.status          = true

  settings.playquotes.status      = false
  settings.praccing.status        = false

  settings.randomambience.status  = false
  settings.randoms.status         = 2

  settings.rebootsounds.status=1
  settings.recast.status          = false
  settings.recastsleeping.status  = true
  settings.reclay.status          = false
  settings.minionmonitor.status   = true
  settings.regen.status           = 3
  settings.runeinfo.status = 1

  settings.sacsplit.status        = false

  settings.scheme.status          = 2
  settings.shortall.status        = true
  settings.shortid.status         = 2
  settings.showtips.status        = true

  settings.soulsteal.status       = true
  settings.soulaction.status=false
  settings.sellstruggle.status=false
  settings.speedwalk.status       = false
  settings.spellsfall.status=2
  settings.sunsounds.status = false
  settings.swarn.status           = false
  settings.ticksounds.status      = false

  settings.tts.status             = true
  settings.warn.status            = true
end

function sanity_check_config_settings()
  if not settings then settings={} end

  sanity_check_bool_config_setting("ambience",        true)
  sanity_check_bool_config_setting("antigroundstringspam", false)
  sanity_check_bool_config_setting("areamusic",       false)    -- this is too busy with ambience also enabled
  sanity_check_bool_config_setting("autoopen",      false)
  sanity_check_bool_config_setting("showsize",        true)
  sanity_check_bool_config_setting("unexplored",false)
  sanity_check_int_config_setting("automark", 1)
  sanity_check_bool_config_setting("automove",        true)
  sanity_check_bool_config_setting("autopick",        true)
  sanity_check_bool_config_setting("autoregen",       false)

  sanity_check_bool_config_setting("autosleep",       false)
  sanity_check_bool_config_setting("autostat",        true)
  sanity_check_int_config_setting("autotime",        3)
  sanity_check_int_config_setting ("bars",            2)        -- give enemy pitch via pitch change
  sanity_check_int_config_setting ("dcomps",          1)
  sanity_check_int_config_setting ("randomsaction",          2)
  sanity_check_bool_config_setting("battlemusic",     true)
  sanity_check_bool_config_setting("brewlog",         true)
  sanity_check_bool_config_setting("comlog", false)
  sanity_check_bool_config_setting("comlogchans", true, false)
  sanity_check_bool_config_setting("comlogclan", false, false)
  sanity_check_bool_config_setting("comlogtells", true, false)
  sanity_check_bool_config_setting("comlogfriends", false, false)
  sanity_check_int_config_setting ("chans",           1)
  sanity_check_bool_config_setting("chist",           false)

  sanity_check_bool_config_setting("clannotify",           false)
  sanity_check_bool_config_setting("clanfame",           false, false)
  sanity_check_bool_config_setting("clanactive",           false, false)
  sanity_check_bool_config_setting("clansize",           false, false)
  sanity_check_bool_config_setting("clanpk",           false, false)

  sanity_check_bool_config_setting("clanwar",         true)
  sanity_check_bool_config_setting("deathaction",      false)
  sanity_check_int_config_setting("deathactionbloodsac", 1, false)
  sanity_check_int_config_setting("deathactionharvestteeth", 1, false)
  sanity_check_int_config_setting("deathactionconsume", 1, false)
  sanity_check_int_config_setting("deathactionspellcomp", 1, false)
  sanity_check_int_config_setting("deathactionsalvage", 1, false)
  sanity_check_bool_config_setting("donfish",         false)
  sanity_check_bool_config_setting("dteeth",          false)

  sanity_check_bool_config_setting("enterinterrupt",  false)
  sanity_check_bool_config_setting("elderBuffer",         false)
  sanity_check_int_config_setting ("exits",           1)
  sanity_check_bool_config_setting("expall",          true)
  sanity_check_bool_config_setting("gdamage",         true)

  sanity_check_bool_config_setting("globalareamusic", true)
  sanity_check_bool_config_setting("grecast",         false)
  sanity_check_int_config_setting("groupdice", 2)
  sanity_check_bool_config_setting("grunts",         true)
  sanity_check_bool_config_setting("ifollow",         false)
  sanity_check_bool_config_setting("imove",           true)

  sanity_check_int_config_setting ("items",           3)
  sanity_check_bool_config_setting("logarena",           true)
  sanity_check_bool_config_setting("logpk",           false)
  sanity_check_int_config_setting ("musictype",       1)
  sanity_check_bool_config_setting("ntrunk",          true)

  sanity_check_bool_config_setting("playquotes",      false)
  sanity_check_bool_config_setting("praccing",        false)
  sanity_check_bool_config_setting("randomambience",  false)
  sanity_check_int_config_setting("randoms",         2)

  sanity_check_int_config_setting("rebootsounds",         1)
  sanity_check_bool_config_setting("recast",          false)
  sanity_check_bool_config_setting("recastsleeping",  true)
  sanity_check_bool_config_setting("reclay",          false)
  sanity_check_bool_config_setting("minionmonitor",   true)
  sanity_check_int_config_setting ("regen",           3)
  sanity_check_int_config_setting("runeinfo", 1)
  sanity_check_bool_config_setting("sacsplit",        false)

  sanity_check_int_config_setting ("scheme",          2)
  sanity_check_bool_config_setting("shortall",        true)
  sanity_check_int_config_setting ("shortid",         2)  
  sanity_check_bool_config_setting("showtips",        true)
  sanity_check_bool_config_setting("shortidcomma",    false)
  sanity_check_bool_config_setting("soulsteal",       true)
  sanity_check_int_config_setting("soulaction", 2, false)
  sanity_check_bool_config_setting("sellstruggle", false, false)
  sanity_check_bool_config_setting("speedwalk",       false)
  sanity_check_int_config_setting("spellsfall",       2)
  sanity_check_bool_config_setting("sunsounds",     false)
  sanity_check_bool_config_setting("swarn",           false)
  sanity_check_bool_config_setting("ticksounds",      false)

  sanity_check_bool_config_setting("tts",             true)
  sanity_check_bool_config_setting("warn",            true)

  -- various containers should get special parms
  if not settings.brewcontainer then settings.brewcontainer={} ss("brewcontainer","") end
  if not settings.container then settings.container={} ss("container","bag") end
  if not settings.sscontainer then settings.sscontainer={} ss("sscontainer",gs("container")) end

  -- volume control should be initialized and set
  sanity_check_int_config_setting ("vol_ambid",    50)
  sanity_check_int_config_setting ("vol_areaid",   50)
  sanity_check_int_config_setting ("vol_global",   50)
  resetvol()

  -- special variable to store our name
  if not settings.me then settings.me={} ss("me","new") end

  -- this clears an old save file case where the setting was being saved boolean
  if settings.me.status == true  then ss("me","new") end
  if settings.me.status == false then ss("me","new") end

  -- create an iuid if necessary
  if not settings.iuid then
    settings.iuid={}
    local temp_iuid = ""..math.random(1000, 9999)..math.random(1000, 9999)..""
    ss("iuid",temp_iuid)
  end
end

function sanity_check_charlist()
  if (charlist == nil) then
    charlist = {}
  end

  -- if we find any boolean values, just crater and be done
  for i, result in pairs (charlist) do
    if (result == true) then
      -- Note("Clearing corrupt charlist table.")
      charlist = {}
      return
    elseif (result == false) then
      -- Note("Clearing corrupt charlist table.")
      charlist = {}
      return
    end
  end
  if (#charlist>=1) then
    if charlist[1]~=nil then --we've got an oldstyle charlist table, convert it
      convert_charlist()
    end -- if we've got an oldstyle charlist
  end -- if 1 or more entries in table
end
-------------------------------------------------------------
-- table that contains various setting related strings
-------------------------------------------------------------

function setup_config_menu_entry(configname, keywords, description)
  if not config_menu_data then
    config_menu_data = {}
  end
  if not config_menu_data[configname] then
    config_menu_data[configname] = {}
  end
  config_menu_data[configname].keywords = keywords
  config_menu_data[configname].desc     = description
end

function settingtables()
  args={}
  args.autotime = {"disabled", "Every hour with text and a small sound", "Every hour with text and a small sound, as well as every 6 hours with an audio announcement"}
  args.automark = {"disabled", "only in groups where I am the leader", "Only in groups where I am not the leader", "in all groups"}
  args.bars={"Pan sounds from left (lowest) to right (highest)", "Sounds that change pitch","Just display the values in text"}
  args.regen={"Never", "Sleeping", "Both sleeping and resting"}
  args.dcomps={"Do nothing", "Store in container", "Discard"}
  args.randomsaction={"Do nothing", "Store in container", "Donate", "Discard"}
  args.deathactionspellcomp={"Disabled", "50% of the time", "Always"}
  args.deathactionconsume={"Disabled", "50% of the times", "Always"}
  args.deathactionbloodsac={"Disabled", "50% of the time", "Always"}
  args.deathactionsalvage={"Disabled", "50% of the time", "Always"}
  args.deathactionharvestteeth={"Disabled", "50% of the time", "Always"}
  args.groupdice={"Disabled", "Group only", "All and Group"}
  args.shortid={"Disabled","Output and history","History only"}
  args.musictype={"Your health", "Target's health"}
  args.randoms={"disabled", "Only when soloing", "Only when leading", "When soloing or leading"}
  args.rebootsounds = {"Play a warning sound", "Play audio announcements"}
  args.scheme={"Heartbeats", "Speech"}
  args.soulaction={"Do nothing with it", "Put it in my container", "Sell it on the soulmarket"}
  args.spellsfall = {"none", "only mine", "only group members", "mine and group members"}
  args.chans={"Play the channel sound and display your message", "Speak your message without displaying it", "Only play the channel sound"}
  args.exits={"Text", "Directional Sounds"}
  args.items={"Put it in a container","Discard it","Do nothing","Donate it","Put it in your locker"}
  args.runeinfo = {"Just show the rune", "Show the rune and it's affects", "Just show the affects"}

  setup_config_menu_entry("ambience",        "ambience",    "Ambience: Area-specific ambient sounds:")
  setup_config_menu_entry("antigroundstringspam", "groundspam spamground stringspam itemspam antigroundstringspam", "Antigroundstring spam: condense many items with the same groundstring into one line:")
  setup_config_menu_entry("areamusic",       "areamusic",   "AreaMusic: Play area-specific background music:")
  setup_config_menu_entry("autoopen",      "autoopen",  "AutoOpen: Automatically open doors after unlocking or picking:")
  setup_config_menu_entry("showsize",      "showsize size",  "show size information when displaying items and people in rooms:")
  setup_config_menu_entry("unexplored",      "unexplored near exits nearexits",  "show nearest unexplored exits (if any) when entering a room")
  setup_config_menu_entry("automark", "automark groupmark mark", "Automark: automatically start marking when I join a group: ")
  setup_config_menu_entry("automove",        "automove",    "AutoMove: Obey leader's climb and look commands:")
  setup_config_menu_entry("autopick",        "autopick",    "AutoPick: Retry lockpicking when it fails:")
  setup_config_menu_entry("autoregen",       "autoregen",   "AutoRegen: Obey leader's regen and sleep commands:")

  setup_config_menu_entry("autosleep",       "autosleep",   "AutoSleep: Sleep when group leader sleeps:")
  setup_config_menu_entry("autostat",        "autostat",    "AutoStat: Display statistics when they change:")
  setup_config_menu_entry("bars",            "bars",        "Bars: Represent the prompt using:")
  setup_config_menu_entry("battlemusic",     "battlemusic", "BattleMusic: Play condition-specific music when fighting:")
  setup_config_menu_entry("brewcontainer",   "brewcontainer vessel", "Vessel: Liquid container used for brewing:")
  setup_config_menu_entry("brewlog",         "brewlog",              "BrewLog: Write brewed recipes to a separate window:")

  setup_config_menu_entry("chans",           "chans chanecho",       "ChanEcho: When you talk on a channel, Mush-Z should:")
  setup_config_menu_entry("chist",           "chist chanhist",       "ChanHist: Write what you say on channels to a separate window:")

  setup_config_menu_entry("clannotify", "clannotify ranknotify", "Clan notify: alert me upon login of changes to my clan's rank (enables other options) ")
  setup_config_menu_entry("clanfame", "clanfame famerank rankfame", "Clan fame: notify me at login when my clan's fame rank changes ")
  setup_config_menu_entry("clanactive", "clanactive clanactivity activerank", "Clan Activity: Notify me at login when my clan's activity rank changes ")
  setup_config_menu_entry("clansize", "clansize sizerank", "Clan Size: Notify me at login when my clan's size changes ")
  setup_config_menu_entry("clanpk", "clanpk clanpkrank clanpk", "Clan PK: Notify me at login when my clan's PK rank rises or falls ")

  setup_config_menu_entry("clanwar",         "clanwar",            "ClanWar: Display clan war notifications and sounds:")
  setup_config_menu_entry("container",       "container",          "Container: Container used for storing various items:")
  setup_config_menu_entry("comlog", "chanlog channellog logchannel comlog logcom", "Comlog: Log all communications you choose to a separate notepad (enables other options):")
  setup_config_menu_entry("comlogtells", "telllog logtells", "com log tells: Log tells to the comlog:")
  setup_config_menu_entry("comlogchans", "logchan", "comlog channels: log channel sends to the com log:")
  setup_config_menu_entry("comlogclan", "logclan comlogclan", "comlog clan: log clantells to the comlog:")
  setup_config_menu_entry("comlogfriends", "logfriends friendslog", "comlog friends: log friend posts to the com log:")
  setup_config_menu_entry("dcomps",          "dcomps",             "DComps: Perform the following action on corpsecutter spell components:")
  setup_config_menu_entry("randomsaction",          "randomsaction",             "RandomsAction: Perform the following action on automatically retrieved random/unique items:")
  setup_config_menu_entry("deathaction",     "deathaction necroaction", "Death action: Automatically perform common tasks on corpses (enables other options):")
  setup_config_menu_entry("deathactionbloodsac",         "autobloodsac bloodsacondeath", "Death action, bloodsac: Automatically bloodsac corpses:")
  setup_config_menu_entry("deathactionharvestteeth", "autoteeth deathactionharvestteeth", "Death action, harvest teeth: Automatically harvest teeth:")
  setup_config_menu_entry("deathactionconsume", "autoconsume deathactionconsume", "Death action, consume: Automatically controll all minions to consume corpses:")
  setup_config_menu_entry("deathactionspellcomp", "autospellcomp deathactionspellcomp", "Death action, spellcomp: Automatically harvest spellcomps from corpses:")
  setup_config_menu_entry("deathactionsalvage", "autosalvage deathactionsalvage", "Death action, salvage: Automatically salvage mechanical parts when possible:")
  setup_config_menu_entry("donfish",         "donfish donatefish", "DonateFish: Automatically donate caught fish:")
  setup_config_menu_entry("dteeth",          "dteeth",             "DTeeth: Automatically discard harvested teeth:")
  setup_config_menu_entry("autotime",          "autotime hour time",             "Time: Automatically announce game time: ")

  setup_config_menu_entry("enterinterrupt",  "enterinterrupt",     "EnterInterrupt: Pressing the enter key interrupts speach:")
  setup_config_menu_entry("elderBuffer",         "elderBuffer",                     "ElderBuffer: Send elder tells to an elders history buffer instead:")
  setup_config_menu_entry("exits",           "exits",              "Exits: Room exits should be conveyed using:")
  setup_config_menu_entry("expall",          "expall",             "ExpAll: Experience from mob deaths reviewable in 'all history' buffer:")
  setup_config_menu_entry("gdamage",         "gdamage weapons",    "Weapons: Play weapon swing and damage sounds:")

  setup_config_menu_entry("globalareamusic", "globalareamusic globalmusic", "GlobalMusic: Play default music for areas without specific tracks:")
  setup_config_menu_entry("grecast",         "grecast",                     "GRecast: Recast certain spells on group members:")
  setup_config_menu_entry("groupdice",         "groupdice",                     "groupdice: Add group dice results to history:")
  setup_config_menu_entry("grunts",         "grunts",    "grunts: Play grunts and other vocal sounds while fighting:")
  setup_config_menu_entry("ifollow",         "ifollow",                     "IFollow: Interrupt screen reader when following someone:")
  setup_config_menu_entry("imove",           "imove",                       "IMove: Interrupt speech when moving:")

  setup_config_menu_entry("items",           "items",                "Items: When you get an item, Mush-Z should:")
  setup_config_menu_entry("logarena",           "logarena arenalog",            "Log Arena: arena enter / leave messages reviewable in the all buffer:")
  setup_config_menu_entry("logpk",           "logpk",                "LogPK: pk fights are reviewable in channel history:")
  setup_config_menu_entry("musictype",       "musictype battletype", "BattleType: The severity of battle music is based on:")
  setup_config_menu_entry("ntrunk",          "ntrunk",               "NTrunk: Truncate large numbers:")

  setup_config_menu_entry("playquotes",      "playquotes",         "PlayQuotes: Play death quote voiceovers:")
  setup_config_menu_entry("praccing",        "praccing practice",  "Practice: Automatically gain a practice when possible:")
  setup_config_menu_entry("randomambience",  "randomambience",     "RandomAmbience: Occasionally play random ambience-enhancing sounds:")
  setup_config_menu_entry("randoms",         "randoms autorandom",            "Randoms: Automatically get random/unique items from corpses:")

  setup_config_menu_entry("rebootsounds",     "rebootsounds",     "Reboot sounds: When notifying you of reboots, Mush-Z should: ")
  setup_config_menu_entry("recastsleeping",  "recastsleeping",     "RecastSleeping: If recast is enabled, cast fallen spells even while sleeping:")
  setup_config_menu_entry("recast",          "recast",             "Recast: Cast certain spells on yourself when they fall:")
  setup_config_menu_entry("reclay",          "reclay",             "Reclay: Automatically cast clay man when the current one dies:")
  setup_config_menu_entry("minionmonitor",          "minionmonitor",             "Minion monitor: Monitor tanking minion health by the use of sounds:")
  setup_config_menu_entry("regen",           "regen",              "Regen: Automatically report regeneration times when:")
  setup_config_menu_entry("runeinfo", "runeinfo runemeanings runes", "Rune Info: when carving or looking at an item with runes, Mush-z should:")
  setup_config_menu_entry("sacsplit",        "sacsplit",           "SacSplit: Split gold obtained from sacrificing corpses:")
  setup_config_menu_entry("scheme",          "scheme",             "Scheme: Mush-Z should convey your health condition using:")
  setup_config_menu_entry("shortall",        "shortall",           "ShortAll: ShortID reviewable in 'all history' buffer:")
  setup_config_menu_entry("shortid",         "shortid",            "ShortID: When identifying an object, simplify the information:")  
  setup_config_menu_entry("shortidcomma",    "shortidcomma comma shortcomma",    "ShortIDComma: Pause between various item effects for easier understandability")
  setup_config_menu_entry("showtips",        "showtips tips autotips",           "ShowTips: Show Mush-Z newbie tips:")

  setup_config_menu_entry("soulsteal",       "soulsteal",          "Soulsteal: Automatically try to cast soulsteal when affected by dread portent:")
  setup_config_menu_entry("soulaction", "soulaction soulstoneaction stoneaction autosell", "Soul action: When Mush-Z automatically steals a soul: ")
  setup_config_menu_entry("sellstruggle", "sellstruggle", "Sell struggle: Sell souls that you struggle to steal: ")
  setup_config_menu_entry("speedwalk",       "speedwalk",          "Speedwalk: Interrupt room description with exits for quick walking:")
  setup_config_menu_entry("spellsfall",           "spellsfall spellsfallinall",          "Spells fall in all: spell fall messages reviewable in all buffer:")
  setup_config_menu_entry("sscontainer",     "sscontainer stones", "Stones: Container used for soulstones:")
  setup_config_menu_entry("sunsounds", "sunsounds dawn dusk", "Sun sounds: Play a sound when the sun rises and sets:")
  setup_config_menu_entry("swarn",           "swarn",              "SWarn: Warn subgroup of falling spells")
  setup_config_menu_entry("ticksounds",      "ticksounds",         "Ticks: Indicate the passage of game time (a mud tick) with sounds:")

  -- WARNING -- settings.tts -- this appears to be a core, mandatory setting.  Do not disable/modify. --

  setup_config_menu_entry("warn",            "warn",               "Warn: Display warnings when spells are near falling")


end
--------------------------------------------------------------------
-- startup clear/system init
--------------------------------------------------------------------

function startup_do_mandatory_var_init()
  -- this is low level startup init that has to be done prior to clear working vars
  -- on first initialization
  SetVariable("version","170610-01")
  if not settings then settings={} end
  if not settings.me then
    settings.me = {}
    settings.me.status = "new"
  end
  if not settings.version then
    settings.version = {}
    settings.version.status = GetVariable("version")
  end
end
function gameTime_external_code()
--This function will run code when the kxwt_time trigger is sent to the client.
--To keep things clean, please try to only include function calls here.

--refresh the exp marker to check for an hour of marking:
hExpMarkHandle(nil,nil,nil,nil,nil,nil,true,true)
end

function startup_clear_working_vars() 
  -- this function can be called at various points in time, including from
  -- the manual control-l reload command.  It's convenient for initialization
  -- and startup as well.
  leader=gs("me")
  exptnl=0
  classtnl="none"
  levtnl=0
  exp=0
expInfo = {}
expInfo.levelTBL = {}
expInfo.lastDeath = 0
expInfo.exp = 0
expInfo.prevexp = 0
expInfo.practices={}
expInfo.practices.requirement = 0
expInfo.practices.count=nil
expInfo.tnl = {}
  exm = {}
exm.events = {}
exm.events.leveled = {}
exm.events.microleveled = {}

  prevlength=0
  prevexp=0
gTime = {}
gTime.pm=false
gTime.hours=0
gTime.minutes=0
gTime.twelveHours=12
end



]]>
</script>
</muclient>
